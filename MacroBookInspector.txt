'MacroName:MacroBookInspector.2016.04
'MacroDescription:Lists the macros in a macro book, along with their descriptions and
' other information. Save the list, or the text of an individual macro, to a text file.
'
' This macro was written by Walter F. Nickeson,
' University of Rochester, Rochester, NY
' wnickeson@library.rochester.edu
'
' Thanks to Joel Hahn for pointing out the file structure of macro books, and for
' instruction afforded by the macros he's shared, and to Harvey Hahn for some inspiration
' in the functionality of this macro with his earlier "MbkTool" macro, although all
' responsibility for this macro is mine alone. Microsoft's specification for its Compound
' File Binary File Format, version v20160714, was retrieved from
' <https://msdn.microsoft.com/en-us/library/dd942138.aspx> on 8 August 2016.
'
' Last updated: 12 August 2016.
' Check for the latest versions of this and my other macros at
' http://docushare.lib.rochester.edu/docushare/dsweb/View/Collection-2556
' Please e-mail me with bug reports or to suggest improvements.
'
' This macro works for me with Connexion client 2.63 and 64-bit Windows 7 Enterprise &
' 64-bit Windows 10 Pro, but no guarantees are promised or implied.
'
'***************************************************************************************#
' How it works: Run the macro to view the macro books in the Connexion "Macros"
' directory. Select a macro book to see a list of the macros in it, its size (in bytes),
' and date of last revision. Select a macro to see some information about it: its size in
' terms of lines (source code) and bytes (for both source and object code), and if
' available, its description, a possible date of revision, and the keystroke shortcut or
' user tool number assigned to it. Its first 25 lines or 1K of source code can be
' displayed separately. The list of macro books and the list of macros in the selected
' macro book can be saved as tab-delimited text files. The text of the selected macro may
' also be saved as a text file. The default save location can be set below on line 292.
' The simple list of macros is placed on the Windows clipboard.
'
' Some simple error checking is done as this macro gathers information: If the length of
' a macro book file is not a multiple of 512, a warning pops up; if the selected macro is
' damaged or corrupt, this program may be able to detect and warn about it; and if the
' name or description of the selected macro differs from what displays in the Connexion
' macro manager, that is noted.
'
' This macro can't analyze macro books larger than 7,143,424 bytes, although that
' capability is possible.
'
' The ability to save the text of a macro directly is useful because the maximum number
' of bytes the Windows clipboard can copy from the macro editor is 65,498. Using this
' macro bypasses that limitation. The reason to save macros as separate text files is, of
' course, the susceptibility of macro books to corruption, in which parts of macros--
' usually at the end--seem to disappear. The best way to backup a macro is by using a
' text file, because restoring a corrupt macro is then a simple matter of pasting the
' text into the macro editor. (Note that it is still possible that the text file saved by
' "MacroBookInspector" may be that of a corrupt macro.) And the simple need to be able to
' produce a list of macros is what drove the development of this macro in the first
' place.
'
' When a macro book is selected, the program scans the file's internal directory for
' names of macros. In that same initial scan it also retrieves the macro descriptions,
' the size in bytes of each macro's source and compiled code, and the information
' required to assemble the macro from all the pieces in which it is stored within the
' file. It then sorts the macros to display in alphabetical order. Depending on the
' number and size of the macros in that macro book, it may take several seconds to
' finish; the macro keeps track of this time. When a macro is selected, it is
' reconstructed to produce the rest of the information to display: the number of lines in
' the original source code, a possible date of last modification, and the first 1K bytes
' of the source text. This macro attempts to find a revision date by searching within the
' first 25 lines of the selected macro for a word like "revised" or "updated" and a
' string of digits that might represent a date from 1998 on. This is not a very precise
' method, but it works for my macros, in which I put revision dates in a standard form.
' (OCLC has unfortunately chosen not to implement the provision in the file format for a
' time stamp for date of creation or modification, an enhancement I believe would be
' extremely useful.) During this pass through the macro text, this program matches "Sub"
' and "End Sub" and "Function" and "End Function" statements. Unmatched statements may
' indicate corruption, or loss of text, and a message box pops up carrying a warning when
' such a problem is found. Because this part of the program can take several seconds for
' a large macro, it is done only when a macro is actually selected, or when a macro book
' contains only a single macro. The display of the description allows for six lines, at
' approximately 60 characters per line. The first 25 lines or so of the selected macro's
' source code can be displayed. (The limit is actually 1024 characters, the limit of the
' contents of a text area in the dialog box, but this macro cuts off the display with a
' complete line, so fewer than 25 lines may actually be given.) To get the keystroke
' shortcut, the macro attempts to find the file "Custom.Keymap.xml" and the macro name in
' that file. If both attempts are successful it extracts the keystrokes for display.
' Otherwise, it attempts the same thing with the "Options.xml" file to get the user tool
' assignment.
'
' Connexion macro books are instances of the Windows Compound File Binary File Format.
' Files in this format contain data in a number of virtual streams. In the case of macro
' book files, each macro appears to be stored in three streams (with the actual data
' being dispersed throughout the file): the source, which is the text entered in the
' editor; the macro description, as entered in the macro manager; and binary data, which
' is (I think) the compiled code.
'
' The file allocates storage space for all its contents in sectors of 512 bytes, with the
' first sector, the Header, containing data about locations within the file and other
' parameters. After opening the selected file, this macro analyzes the Header to extract
' relevant information with which to build the different streams. The first stream that
' must be built is the FAT, Microsoft's term for an array which represents the sectors of
' the file (although a better term for it might be "SAT," for "sector allocation table").
' The FAT is the basis for constructing all the other streams, or chains of sectors. The
' MiniFAT is another stream that, as an array, represents the minisectors in the file.
' Minisectors are units of 64 bytes contained within the larger sectors; the complete
' chain of minisectors forms the Ministream. Similarly, the directory is also a stream,
' and contains other crucial location information. To extract macro names and
' descriptions, the macro begins by building the FAT, which is then used to construct the
' MiniFAT, the directory stream, and the Ministream. When these pieces are in place the
' macro names are found in the directory stream, which is also where the locations of the
' macro descriptions within the Ministream are stored. (It is also where date information
' may be stored, but which OCLC has chosen not to do.) This macro sorts the unique macro
' names and attaches to each the appropriate description. When a macro is selected, its
' source code is reconstructed by starting at the location where it begins (named in the
' directory) and following the chain of sectors named in the FAT (or MiniFAT), assembling
' the contents of those sectors until it is complete. In the construction of the macro
' some kinds of corruption may be detected. This step is done only once for each macro;
' the results are stored in an array for recall if the macro is selected again.
'****************************************************************************************

Option Compare Text  'Forces case-insensitive string comparison in "InStr" and "StrComp".
Option Explicit

Declare Sub AssembleMacroInfo    ( Selection% )
Declare Sub BuildDataStream      ( FirstSector&, WhichFAT%, StreamSize& )
Declare Sub BuildFAT             ( TotalSectorsInFAT% )
Declare Sub BuildMiniFAT         ( TotalSectorsInMiniFAT%, FirstSectorOfMiniFAT% )
Declare Sub BuildMinistream      ( MinistreamStart& )
Declare Sub GetDirectoryEntries  ( FirstSectorOfDirectory& )
Declare Sub GetEnviroVars
Declare Sub GetFileInfo          ( SelectedMbkFile$ )
Declare Sub GetMacroBookFiles
Declare Sub GetMacroInfo         ( MacroDirectoryInfo$ )
Declare Sub GetMacroNames
Declare Sub MakeMacroList        ( SelectedMbkFile$ )
Declare Sub ReadFile             ( FileName$ )
Declare Sub ShowTimes
Declare Sub SortMacroNames       ( NewestName$ )
Declare Sub StoreWithTerminator  ( WhichArray% )
Declare Sub WriteFile            ( SaveType% )

Declare Function FindRevisionDate( MacroLine$ )                 As String
Declare Function FormatDuration  ( BeginTime#, EndTime# )       As String
Declare Function FormatTimeButton( TimeString$ )                As String
Declare Function GetKeyAssignment( FullMacroName$ )             As String
Declare Function GetSectorData   ( SectorID&, WhichDataArray% ) As String
Declare Function HexVal          ( InBytes$ )                   As Long
Declare Function MatchCalls      ( MacroLine$, LineCount& )     As String

Declare Function Dialog1ControlFunction( Id$, Action%, SuppVal& )
Declare Function Dialog3ControlFunction( Id$, Action%, SuppVal& )

Global Const CONTROL_CHANGE       As Integer = 2      'The value of the dialog box function parameter "Action%" when a control changes.
Global Const DATA_SUBSTRING_64    As Integer = 64     'The number of characters in some of the substrings of the master macro information string.
Global Const DATA_SUBSTRING_8     As Integer = 8      'The number of characters in some of the substrings of the master macro information string.
Global Const DIR_ENTRY_LENGTH     As Integer = 128    'The length in bytes of a directory entry.
Global Const DWORD                As Integer = 4      'The length in bytes of sector numbers and some other values.
Global Const END_OF_CHAIN         As Integer = -2     'Hex FFFFFFFE, marks the end of a chain of sectors in the FAT.
Global Const FILE_DATA            As Integer = 1      'The switch to control processing of array to end elements with LF character.
Global Const FILE_EXTENSION       As Integer = 4      'The length of string "dot + filename extension," e.g. ".mbk" = 4 characters.
Global Const INITIALIZE           As Integer = 1      'The value of the dialog box function parameter "Action%" when the dialog box opens.
Global Const KEEP_DLG_OPEN        As Integer = -1     'The value of the dialog box function to keep a dialog box open.
Global Const MAIN_C               As Integer = 0      'The switch to access main data array or main FAT array.
Global Const MAX_LEN_MACRO_NAME   As Integer = 28     'The maximum length in characters of a macro name, plus 1.
Global Const MAX_SIZE_MINISTREAM  As Integer = 4096   'The maximum size in bytes of object stored in Ministream.
Global Const MAX_STRING_LENGTH    As Integer = 31744  'The largest even multiple of 512 below 32767, OML's limit on string length.
Global Const MINI_C               As Integer = 1      'The switch to access Ministream or miniFAT array.
Global Const MINI_SECTOR_SIZE     As Integer = 64     'The size in bytes of minisectors.
Global Const OFFSET_BIN_LENGTH    As Integer = 45     'The start of the substring in the macro name string containing the length of the data stream.
Global Const OFFSET_DESC          As Integer = 53     'The start of the substring in the macro name string containing the macro description.
Global Const OFFSET_FIRST_SECTOR  As Integer = 29     'The start of the substring in the macro name string containing the first sector of the data.
Global Const OFFSET_SRC_LEN       As Integer = 37     'The start of the substring in the macro name string containing the length of the data stream.
Global Const REV_WORDS            As Integer = 7      'The number of words indicating revision.
Global Const SAVE_LIST            As Integer = 0      'The switch to save the list of macros to a file.
Global Const SAVE_MACRO           As Integer = 1      'The switch to save the text of a macro to a file.
Global Const SECTOR_SIZE          As Integer = 512    'The size in bytes of normal or regular sectors.
Global Const STREAM_DATA          As Integer = 0      'The switch to control processing of array to end elements with LF character.
Global Const STREAM_START         As Integer = 117    'The first sector location for a stream object. This offset is from the beginning of the
                                                      ' directory sector.
Global Const STRING1_EQUAL_TO     As Integer = 0      'The value of the "StrComp" function when strings 1 and 2 are the same.
Global Const STRING1_GREATER_THAN As Integer = 1      'The value of the "StrComp" function when string 1 is greater than string 2.
Global Const STRING1_LESS_THAN    As Integer = -1     'The value of the "StrComp" function when string 1 is less than string 2.
Global Const STRING_OFFSET        As Integer = 1      'A number to make up the difference between 0-based (file offset) and 1-based
                                                      ' (character positions in strings) counting.
Global Const WARNING_MESSAGE      As Integer = 48     'The value to display the "Warning message" icon in a message box.

Global Const MACRO_INFO_BIN       As Integer = 7      'These are the numbers of the substrings in the string holding macro information.
Global Const MACRO_INFO_BOOK      As Integer = 2
Global Const MACRO_INFO_DATE      As Integer = 3
Global Const MACRO_INFO_DESC      As Integer = 9
Global Const MACRO_INFO_KEY       As Integer = 8
Global Const MACRO_INFO_LINES     As Integer = 5
Global Const MACRO_INFO_MATCH     As Integer = 11
Global Const MACRO_INFO_NAME      As Integer = 1
Global Const MACRO_INFO_PREVIEW   As Integer = 14
Global Const MACRO_INFO_REV       As Integer = 4
Global Const MACRO_INFO_SRC       As Integer = 6
Global Const MACRO_INFO_TIME      As Integer = 10
Global Const MACRO_INFO_XDESC     As Integer = 13
Global Const MACRO_INFO_XNAME     As Integer = 12

Global LineCountStr As String * DATA_SUBSTRING_64
Global MacroSizeStr As String * DATA_SUBSTRING_64

Global CR$
Global DefaultSavePath$
Global DoubleQuote$
Global FATSectorListInHeader$
Global FileInfo$
Global FileSize&
Global FileSizeKB%
Global FileSizeKBStr$
Global FirstSector&
Global FullMacroName$
Global LineCount&
Global LineCountReport$
Global MacroBookFile$
Global MacroBookList$
Global MacroBookName$
Global MacroCount%
Global MacroDesc$
Global MacroDirectoryPath$
Global MacroRevisionDate$
Global MatchCache$
Global MatchWarning$
Global PreviewLines$
Global PreviousEntry%
Global ProgramFilesPath$
Global SaveCount%
Global SaveFileName$
Global SelectedMacroIndex%
Global SelectedMacroName$
Global SingleQuote$
Global SourceName$
Global StreamSize&
Global SummaryMacroCount$
Global TabChar$
Global TestString$
Global TotalMacroCount%
Global UserProfile$
Global WaltsMacros$
Global WhichFAT%

Global DataStream()             As String
Global DirectoryEntries()       As String
Global EndWithLF()              As String
Global FAT()                    As Long
Global FileSections()           As String
Global FileSectors()            As String
Global MacroBooks()             As String
Global MacroListNames()         As String
Global MacroListPlus()          As String
Global MasterMacroArray()       As String
Global MiniFAT()                As Long
Global MinistreamSectors()      As String
Global PreviousSaves()          As String
Global UpdateClues( REV_WORDS ) As String
Global UpdateDate()             As String

Global DifferentDesc
Global InvalidFileLength

' Timing variables to calculate speed of macro TimeButton.

Global BeginBF#   'Elapsed time to build the FAT
Global FinishBF#  ' (Build FAT)
Global TimeBF$
Global BeginBMF#  'Elapsed time to build the MiniFAT
Global FinishBMF# ' (Build Mini FAT)
Global TimeBMF$
Global BeginBMS#  'Elapsed time to build the Ministream
Global FinishBMS# ' (Build Mini Stream)
Global TimeBMS$
Global BeginDS#   'Elapsed time to extract and sort the list of names
Global FinishDS#  ' (Directory Sort)
Global TimeDS$
Global BeginGMI#  'Elapsed time to get information about a single macro
Global FinishGMI# ' (Get Macro Information)
Global TimeGMI$
Global BeginMML#  'Total elapsed time to build the macro list
Global FinishMML# ' (Make Macro List)
Global TimeMML$

'****************************************************************************************

Sub Main

'====  CHANGE THIS FILE PATH IF DESIRED  ================================================
' The file name will be appended to this path as the default option when saving. OML does
' not have the resources to present a proper Save dialog, with the ability to easily
' navigate through directories, so this macro simply offers a text box to enter a
' complete file name. Edit this line to identify the place where macros are most likely
' to be saved, and the Save dialog will use it (but the path can be edited to save files
' anywhere).

DefaultSavePath$ = "J:\ConnexionMacros\"
'========================================================================================

Dim MacroYears%

Dim i As Integer

' Initialize some global variables.

CR$                   = Chr$( 013 ) & Chr$( 010 )
DoubleQuote$          = Chr$( 034 )
MacroDirectoryPath$   = "\OCLC\Connexion\Program\Macros\"
SingleQuote$          = Chr$( 039 )
TabChar$              = Chr$( 009 )
WaltsMacros$          = "[Walt's macros] MacroTools:MacroBookInspector"
ReDim PreviousSaves( 0 )

' The catalog of words indicating revision; "updated" is first because that's the term I
' use in my macros.

UpdateClues( 0 ) = "updated"
UpdateClues( 1 ) = "revised"
UpdateClues( 2 ) = "modified"
UpdateClues( 3 ) = "revision"
UpdateClues( 4 ) = "edited"
UpdateClues( 5 ) = "altered"
UpdateClues( 6 ) = "created"
UpdateClues( 7 ) = "adapted"

' The catalog of possible dates of revision of macros--1998 to the present (although what
' macro has survived from 1998????).

MacroYears% = Year( Now() ) - 1998
ReDim UpdateDate( MacroYears% )
For i = 0 To MacroYears%
  UpdateDate( i ) = Trim$( Str$( 1998 + MacroYears% - i ) )
Next i

Call GetMacroBookFiles

' Variables in Sub Main.

Dim Clipbord$                : Clipbord$       = "This list of macros (names only) has been placed on the Windows clipboard. Save the list to a file to include the descriptions."
Dim PreviewMessage$          : PreviewMessage$ = "View first 25 lines or 1K of selected macro."
Dim SelectingBooks$
Dim SelectingMacros$

' Prepare the legends for the dialog box.

SelectingBooks$  = "<== Select a macro book from the drop-down list to view its macros."
SelectingBooks$  = SelectingBooks$ & " Please be patient after making the selection."
SelectingBooks$  = SelectingBooks$ & " Depending on the size of the macro book file and the"
SelectingBooks$  = SelectingBooks$ & " number of macros in the macro book (among other things),"
SelectingBooks$  = SelectingBooks$ & " the macro list may take several seconds to load."

SelectingMacros$ = "Select a macro to display information about it."
SelectingMacros$ = SelectingMacros$ & " Please be patient with this part of the macro too. It may take"
SelectingMacros$ = SelectingMacros$ & " several seconds to gather information about large macros (those"
SelectingMacros$ = SelectingMacros$ & " with over about 600 lines)."

Begin Dialog Dialog1Definition  342, 226, WaltsMacros$, .Dialog1ControlFunction
  OkButton      268, 200,  64,  16
  PushButton     10, 174,  56,  14, "Save &list...",    .SaveList
  PushButton     82, 174,  56,  14, "Save &macro...",   .SaveMacro
  PushButton    168, 174,  56,  14, "&Preview",         .PreviewButton
  PushButton     10, 206,  24,  10, "",                 .TimeButton
  CancelButton    1,   1,   1,   1
  DropListBox    10,  10, 128, 112, MacroBooks(),       .ListOfMacroBooks
  Text          148,  38, 184,  32, SelectingMacros$,   .SelectMacro
  Text          148,  78, 184,  24, Clipbord$,          .Clipboard
  ListBox        10,  38, 128, 138, MacroListNames(),   .ListOfMacros
  GroupBox      148,  34, 184,  58, "",                 .OutlineInfo
  GroupBox      148, 100, 184,  68, "",                 .OutlineDesc
  Text          148,  10, 176,  52, SelectingBooks$,    .SelectBooks
  Text          148,  12, 136,   8, FileInfo$,          .FileInfo
  Text          286,  12,  48,   8, "",                 .FileKBs
  Text           10,  28,  48,   8, SummaryMacroCount$, .MacroCount
  Text          156,  46, 166,   8, "",                 .RevDate
  Text          156,  56, 166,   8, "",                 .MacroLines
  Text          156,  66, 166,   8, "",                 .MacroSize
  Text          156,  76, 166,   8, "",                 .Shortcut
  Text          156, 112, 166,  48, "",                 .Description
  Text          155,  86, 171,   8, "",                 .NameDiffers
  Text          232, 174, 100,  16, PreviewMessage$,    .PreviewText
  GroupBox      154,  82, 172,  15, "",                 .NameDiffersBox
End Dialog

Dim Dialog1 as Dialog1Definition
On Error Resume Next
Dialog Dialog1

End Sub

'****************************************************************************************

Sub AssembleMacroInfo( Selection% )

' This sub assembles all the bits of macro information into one string for ease of
' insertion into the dialog box display.

Dim DisplayMacroName$
Dim MacroInfo$
Dim MacroListSelection$

Dim i As Integer, p As Integer, z As Integer

MacroListSelection$ = MacroListPlus( Selection% )
SelectedMacroName$  = Trim$( Left$( MacroListSelection$, MAX_LEN_MACRO_NAME ) )

' Because the ampersand tends to disappear in dialog boxes, this loop adds a second
' ampersand to make sure it displays properly.

DisplayMacroName$   = SelectedMacroName$
i = 1
Do
  p = InStr( i, DisplayMacroName$, "&" )
  If p <> 0 Then
      DisplayMacroName$ = Left$( DisplayMacroName$, p ) & "&" & Mid$( DisplayMacroName$, p + 1 )
      i = p + 2
  End If
Loop Until p = 0

' Run the timer to see how long the busy part of the macro takes--the sub that
' reconstructs the text of the macro and checks for some kinds of errors. That sub also
' gets some of the information that is assembled into the master string that contains
' everything necessary to display.

BeginGMI#       = Timer
Call GetMacroInfo( MacroListSelection$ )
FinishGMI#      = Timer
TimeGMI$        = FormatDuration( BeginGMI#, FinishGMI# )

' Build the string containing macro information.

MacroInfo$      = DisplayMacroName$
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_BOOK,    MacroBookName$,                                                            TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_DATE,    Mid$( FileInfo$, 20 ),                                                     TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_REV,     MacroRevisionDate$,                                                        TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_LINES,   Trim$( Str$( LineCount& ) ),                                               TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_SRC,     Trim$( Mid$( MacroListSelection$, OFFSET_SRC_LEN, DATA_SUBSTRING_8 ) ),    TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_BIN,     Trim$( Mid$( MacroListSelection$, OFFSET_BIN_LENGTH, DATA_SUBSTRING_8 ) ), TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_DESC,    Trim$( Mid$( MacroListSelection$, OFFSET_DESC ) ),                         TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_TIME,    TimeGMI$,                                                                  TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_MATCH,   MatchWarning$,                                                             TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_XNAME,   SourceName$,                                                               TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_XDESC,   DifferentDesc,                                                             TabChar$ )
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_PREVIEW, PreviewLines$,                                                             TabChar$ )
FullMacroName$  = MacroBookName$ & "!" & SelectedMacroName$
MacroInfo$      = SetField$( MacroInfo$, MACRO_INFO_KEY,     GetKeyAssignment( FullMacroName$ ),                                        TabChar$ )

' The first dimension of the master array is the index number of the macro list. The
' second dimension holds the string containing macro information in the first element,
' and the macro text in subsequent elements. The array can expand as much as necessary to
' accommodate large macros.

MasterMacroArray( SelectedMacroIndex%, 0 ) = MacroInfo$
z = UBound( DataStream )
If z >= UBound( MasterMacroArray, 2 ) Then
    ReDim Preserve MasterMacroArray( TotalMacroCount%, z + 1 )
End If
For i = 0 To z
  MasterMacroArray( SelectedMacroIndex%, i + 1 ) = DataStream( i )
Next i

End Sub

'****************************************************************************************

Sub BuildDataStream( FirstSector&, WhichFAT%, StreamSize& )

' Given the first sector of a data stream, whether the stream is in the Ministream or
' not, and how long the stream is, this subprogram builds the data stream from the chain
' of sectors in either the FAT or the MiniFAT.

Dim DataStreamIndex%
Dim ExpectedSectorCount%
Dim NextSector&
Dim PrevSector&
Dim SectorsRead%
Dim StreamChunkRemainder%
Dim StreamChunks%
Dim StreamSegment$

Dim z As Long

' Calculate some parameters. Given the length of the data stream, determine how many
' elements in the storage array to allocate, and how many sectors comprise the stream.

StreamChunks%         = StreamSize& \ MAX_STRING_LENGTH
StreamChunkRemainder% = StreamSize& Mod MAX_STRING_LENGTH
If StreamChunkRemainder% = 0 Then
    StreamChunks% = StreamChunks% - 1
End If

If StreamSize& < MAX_SIZE_MINISTREAM Then
    ExpectedSectorCount% = StreamSize& \ MINI_SECTOR_SIZE
    If StreamSize& Mod MINI_SECTOR_SIZE > 0 Then
        ExpectedSectorCount% = ExpectedSectorCount% + 1
    End If
  Else
    ExpectedSectorCount% = StreamSize& \ SECTOR_SIZE
        If StreamSize& Mod SECTOR_SIZE > 0 Then
        ExpectedSectorCount% = ExpectedSectorCount% + 1
    End If
End If

' ReDim the array according to how many strings of 31744 or fewer bytes are going to be
' stored, and then start reading the stream from the sector given in either the FAT or
' the miniFAT.

ReDim DataStream( StreamChunks% )
PrevSector&     = FirstSector&
StreamSegment$  = GetSectorData( FirstSector&, WhichFAT% )
SectorsRead%    = SectorsRead% + 1

' Keep reading the sectors in the chain from whichever FAT has been declared. When the
' end-of-chain marker has been reached, put the string into the array.

Do
  If WhichFAT% = MAIN_C Then
      NextSector& = FAT( PrevSector& )
    Else
      NextSector& = MiniFAT( PrevSector& )
  End If
  If NextSector& = END_OF_CHAIN Then
      If StreamChunks% = 0 Or z < MAX_STRING_LENGTH Then
          DataStream( DataStreamIndex% ) = Left$( StreamSegment$, StreamChunkRemainder% )
        Else
          DataStream( DataStreamIndex% ) = Left$( DataStream( DataStreamIndex% ), StreamChunkRemainder% )
      End If
      Exit Do
    Else
      StreamSegment$ = StreamSegment$ & GetSectorData( NextSector&, WhichFAT% )
      SectorsRead%   = SectorsRead% + 1
      PrevSector&    = NextSector&
      z = Len( StreamSegment$ )
      If z = MAX_STRING_LENGTH Then
          If z < StreamSize& Then
              DataStream( DataStreamIndex% ) = StreamSegment$
              DataStreamIndex%               = DataStreamIndex% + 1
              StreamSegment$                 = ""
          End If
      End If
  End If
Loop Until NextSector& = END_OF_CHAIN Or SectorsRead% > ExpectedSectorCount%

' This little piece detects some FAT errors but gives only a general warning that the
' expected size of the data does not match the actual size read.

If SectorsRead% <> ExpectedSectorCount% Then
    MsgBox "The macro is corrupt!" & CR$ & _
           "StreamSize& = " & Str$(StreamSize&) &  CR$ & _
           "ExpectedSectorCount% = " & Str$( ExpectedSectorCount% ) & ", SectorsRead% = " & _
           Str$( SectorsRead% ) & CR$ & Left( DataStream(0), 256 ), WARNING_MESSAGE, WaltsMacros$
End If

End Sub

'****************************************************************************************

Sub BuildFAT( TotalSectorsInFAT% )

' This subprogram builds the FAT, an array that maps the contents of the file. The index
' of the array corresponds to the complete list of 512-byte sectors in the file (starting
' with the sector that follows the Header, sector 0), and each element in the array is
' the ID of the next sector in that particular stream:
'
'           sector ID:    0    1    2    3    4    5    6    7    8    9
'   ID of next sector:   -3    4   63    5    7    6    8   13    9   10
'
' In this file, element 0 of the array, corresponding to sector 0 of the file, or bytes
' 512 to 1023 (character positions 513-1024) of the file, contains a special value that
' identifies it as a sector that contains the FAT. Sector 1 (bytes 1024-1535) contains
' directory data, and was identified as such in the Header (offset 48, stored in the
' variable "FirstSectorOfDirectory%"). The next sector in the directory stream is 4,
' which is chained to sector 7, etc. Sector 2 contains minisector data (this also was
' identified in the Header; see comments in the next Sub). The next sector in the stream,
' therefore also containing minisector data, is 63. Sector 3 contains other data, and the
' sector containing the data that follows it is sector 5, and so on. The special ID
' numbers that carry metadata information are:
'   -3 (hex FFFFFFFD) : sector contains (part of) the FAT
'   -2 (hex FFFFFFFE) : the end of a stream (the last data in the stream was in the previous sector)
'   -1 (hex FFFFFFFF) : an empty, or free, sector.

Dim Break%                   : Break%           = 1
Dim FATSectorsCount%
Dim FATSectorString$
Dim Index%
Dim SectorContents&
Dim SectorCount%
Dim SectorID&

Dim FATSectorIDs() As Long

' The first step is to get the sector IDs of the sectors that comprise the FAT. The first
' 109 of those sector IDs, along with their total count, are found in the Header. Put
' those sector IDs into an array that might look like this:
'
'          index of array:    0    1    2    3    4
'   ID of next FAT sector:    0  128  256  384  512

For FATSectorsCount% = 0 To TotalSectorsInFAT% - 1
  SectorID& = HexVal( Mid$( FATSectorListInHeader$, FATSectorsCount% * DWORD + 1, DWORD ) )
  ReDim Preserve FATSectorIDs( FATSectorsCount% )
  FATSectorIDs( FATSectorsCount% ) = SectorID&
Next FATSectorsCount%

' Each sector named in the array just assembled consists entirely of a list of sector IDs
' (128 sector IDs at 4 bytes each = 512 bytes = 1 sector). The next step is to
' concatenate all those lists into a single string. Finally, finish building the FAT by
' breaking the string into the 4-byte elements of the FAT array.

For SectorCount% = 0 To TotalSectorsInFAT% - 1
  FATSectorString$ = GetSectorData( FATSectorIDs( SectorCount% ), MAIN_C )
  Do While Break% < Len( FATSectorString$ )
    SectorContents& = HexVal( Mid$( FATSectorString$, Break%, DWORD ) )
    ReDim Preserve FAT( Index% )
    FAT( Index% )   = SectorContents&
    Break%          = Break% + DWORD
    Index%          = Index% + 1
  Loop
  Break% = 1
Next SectorCount%

End Sub

'****************************************************************************************

Sub BuildMiniFAT( TotalSectorsInMiniFAT%, FirstSectorOfMiniFAT% )

' This subprogram builds the MiniFAT, an array that parallels the FAT, except that it
' maps not the sectors of the file, but minisectors--sectors of 64 bytes, or 1/8 of a
' sector. Otherwise, it works the same way, with the index of the array corresponding to
' the cardinal number of those minisectors, and the elements of the array indicating the
' next segment in the appropriate stream. This array might look like this:
'
'           mini sector ID:    0    1    2    3    4    5    6    7    8    9
'   ID of next mini sector:  268    2   35   -2    5    6    7    8    9   10
'
' Here, data in the first minisector is followed by data in the minisector whose ID is
' 268. Data in minisector 1 is followed by data in minisector 2, and then data in
' minisector 35. Minisector 3 contains the metadata value that indicates that the stream
' that it terminates (wherever that stream started) is complete.

Dim Break%                   : Break% = 1
Dim FATSectorString$
Dim Index%
Dim MiniFATSectorsCount%
Dim SectorContents&
Dim SectorCount%
Dim SectorID&

Dim MiniFATSectorIDs() As Long

' Begin by getting the sector IDs (as listed in the FAT) of those sectors containing data
' about minisectors (as opposed to the data contained in the minisectors). This
' intermediate array is a list of sector IDs; each of the named sectors contains 128 IDs
' of minisectors:
'
'   index of array:    0    1    2    3    4    5
'     ID of sector:    2   63   80  294  588  613
'
' This tells us that sector 2 contains the beginning of the list of minisectors (this
' sector was identified in the Header by bytes 60-63, read into the variable
' "FirstSectorOfMiniFAT%"), and is continued by the 128 minisector IDs contained in
' sector 63, then those in sector 80, and so on.

If FirstSectorOfMiniFAT% <> END_OF_CHAIN Then
    SectorID&                                = FirstSectorOfMiniFAT%
    ReDim MiniFATSectorIDs( MiniFATSectorsCount% )
    MiniFATSectorIDs( MiniFATSectorsCount% ) = FirstSectorOfMiniFAT%
    For MiniFATSectorsCount% = 1 To TotalSectorsInMiniFAT% - 1
      ReDim Preserve MiniFATSectorIDs( MiniFATSectorsCount% )
      MiniFATSectorIDs( MiniFATSectorsCount% ) = FAT( SectorID& )
      SectorID&                                = FAT( SectorID& )
    Next MiniFATSectorsCount%

' Each sector named in the array just assembled consists entirely of a list of sector IDs
' (128 sector IDs at 4 bytes each = 512 bytes = 1 sector). The next step is to
' concatenate all those lists into a single string. Finally, finish building the MiniFAT
' by breaking the string into the 4-byte elements of the MiniFAT array.

    For SectorCount% = 0 To TotalSectorsInMiniFAT% - 1
      FATSectorString$ = GetSectorData( MiniFATSectorIDs( SectorCount% ), MAIN_C )
      Do While Break% < Len( FATSectorString$ )
        SectorContents&   = HexVal( Mid$( FATSectorString$, Break%, DWORD ) )
        ReDim Preserve MiniFAT( Index% )
        MiniFAT( Index% ) = SectorContents&
        Break%            = Break% + DWORD
        Index%            = Index% + 1
      Loop
      Break% = 1
   Next SectorCount%
End If

End Sub

'****************************************************************************************

Sub BuildMinistream( MinistreamStart& )

' This subprogram creates an array containing the contents of the minisectors,
' parallelling the array that contains the contents of the file ("FileSectors"). The
' minisectors contain data in 64-byte chunks, and any particular ministream may contain
' up to 64 minisectors, for a maximum size of 4096 bytes. (Longer streams are stored in
' regular, or normal, 512-byte sectors with no maximum length.) The Connexion client
' stores macro descriptions (as well as short macros) in these ministreams. Note that
' when considering regular or normal 512-byte sectors, sector 0 always starts at byte 512
' of the file, but that when considering minisectors, the beginning of the stream of
' minisectors may be located anywhere in the file; its location is identified in the root
' entry in the directory. In the macro book files, the Ministreams seem to begin most
' often in sector 3.

Dim MiniSecID%
Dim MinistreamPortion$
Dim NextSector&

Dim MinistreamSectorIDs() As Long

Dim i As Integer, j As Integer

' The root entry of the directory tells which sector contains the first data of the Mini-
' stream and how long the whole Ministream is. With this information an array can be
' built which lists the sectors that contain data in the Ministream:
'
'   index of array:    0    1    2    3    4    5    6    7    8    9
'     ID of sector:   73  127  129  130  131  132  133  143  144  145
'
' Sector 73 (beginning at byte 37888) contains the beginning of the Ministream (that is,
' the first eight minisectors, as there are eight minisectors of 64 bytes in a 512-byte
' sector), which is continued in sectors 127, 129, and so on. This sequence is copied
' from the FAT.

ReDim Preserve MinistreamSectorIDs( 0 )
MinistreamSectorIDs( 0 ) = MinistreamStart&
MiniSecID%               = 1

Do
  NextSector& = FAT( MinistreamSectorIDs( MiniSecID% - 1 ) )
  If NextSector& = END_OF_CHAIN Then
      Exit Do
    Else
      ReDim Preserve MinistreamSectorIDs( MiniSecID% )
      MinistreamSectorIDs( MiniSecID% ) = NextSector&
      MiniSecID% = MiniSecID% + 1
  End If
Loop Until NextSector& = END_OF_CHAIN

' Store the contents of each of the sectors listed in MinistreamSectorIDs in an array
' whose elements are strings with maximum length 31744. Thus, each element of this array
' holds the data of up to 496 minisectors.

For i = 0 To UBound( MinistreamSectorIDs )
  MinistreamPortion$ = MinistreamPortion$ & GetSectorData( MinistreamSectorIDs( i ), MAIN_C )
  If Len( MinistreamPortion$ ) = MAX_STRING_LENGTH Then
      ReDim Preserve MinistreamSectors( j )
      MinistreamSectors( j ) = MinistreamPortion$
      MinistreamPortion$     = ""
      j = j + 1
    Else
      If i = UBound( MinistreamSectorIDs ) Then
          ReDim Preserve MinistreamSectors( j )
          MinistreamSectors( j ) = MinistreamPortion$
      End If
  End If
Next i

End Sub

'****************************************************************************************

Sub GetDirectoryEntries( FirstSectorOfDirectory& )

' Given the ID of the first sector containing directory data, this subprogram follows the
' chain of directory sectors as given in the FAT to create an array of all the directory
' entries in the macro book. Invalid entries will be rejected later.

Dim DirectorySector$
Dim EntryCount%
Dim NextSector&
Dim PrevSector&
Dim SectorQuarter%

Dim i As Integer

NextSector& = FirstSectorOfDirectory&

Do
  If NextSector& = END_OF_CHAIN Then
      Exit Do
    Else
      DirectorySector$ = GetSectorData( NextSector&, MAIN_C )

' Each 512-byte sector contains four 128-byte directory entries, so fill the array four
' elements at a time by breaking up the sector into its quarters.

      SectorQuarter%   = 0
      ReDim Preserve DirectoryEntries( EntryCount% + 3 )
      For i = EntryCount% To EntryCount% + 3
        DirectoryEntries( i ) = Mid$( DirectorySector$, ( SectorQuarter% * DIR_ENTRY_LENGTH ) + STRING_OFFSET, DIR_ENTRY_LENGTH )
        SectorQuarter%        = SectorQuarter% + 1
      Next i
      PrevSector&      = NextSector&
      NextSector&      = FAT( PrevSector& )
      EntryCount%      = EntryCount% + 4
  End If
Loop Until NextSector& = END_OF_CHAIN

End Sub

'****************************************************************************************

Sub GetEnviroVars

' This subprogram finds the user profile string and the path of the Program Files folder
' as found in the environment table. These two strings are used to get all the files this
' macro reads.

Const MAX_TRIES As Integer = 128   'A limit to avoid an endless search!

Dim EnvironmentString$

Dim i As Integer, j As Integer

Do
  EnvironmentString$ = Environ( i )
  If Left$( EnvironmentString$, 13 ) = "ProgramFiles=" Then
      ProgramFilesPath$ = Mid$( EnvironmentString$, 14 )
      j = j + 1
  End If
  If Left$( EnvironmentString$, 12 ) = "USERPROFILE=" Then
      UserProfile$ = Mid$( EnvironmentString$, 13 )
      j = j + 1
  End If
  If j = 2 Then
      Exit Sub
  End If
  i = i + 1
Loop Until EnvironmentString$ = "" Or i > MAX_TRIES

ProgramFilesPath$ = "C:\Program Files"
UserProfile$      = ""

End Sub

'****************************************************************************************

Sub GetFileInfo( SelectedMbkFile$ )

' This subprogram gets important information about the selected macro book file.

Dim i As Integer

InvalidFileLength = FALSE

MacroBookName$ = SelectedMbkFile$
MacroBookFile$ = MacroDirectoryPath$ & MacroBookName$ & ".mbk"
FileInfo$      = "File last updated: " & FileDateTime( MacroBookFile$ )
FileSize&      = FileLen( MacroBookFile$ )

' A file whose length is NOT a multiple of 512 is corrupt in some way, even though its
' macros may display (and even execute) correctly.

If FileSize& Mod SECTOR_SIZE <> 0 Then
    InvalidFileLength = TRUE
End If
FileSizeKB%    = Format( FileSize& / 1000, "#" )
FileSizeKBStr$ = Trim$( Str$( FileSizeKB% ) )
If Len( FileSizeKBStr$ ) > 3 And Len( FileSizeKBStr$ ) < 7 Then
    FileSizeKBStr$ = Left$( FileSizeKBStr$, Len( FileSizeKBStr$ ) - 3 ) & "," & Mid$( FileSizeKBStr$, Len( FileSizeKBStr$ ) - 2 )
End If

Call ReadFile( MacroBookFile$ )

For i = 0 To UBound( FileSections )
  ReDim Preserve FileSectors( i )
  FileSectors( i ) = FileSections( i )
Next i
Erase FileSections

End Sub

'****************************************************************************************

Sub GetMacroBookFiles

' This macro makes the list of macro book files in the "Macros" folder, checking all
' candidates for both the proper extension and also the correct first eight bytes.

Dim FileCounter%
Dim FileNumber%
Dim First8Bytes As String*DATA_SUBSTRING_8
Dim HeaderSignature$
Dim MacroDirectoryFiles$
Dim Possibility$

' Test that the file is really a macrobook file, no matter its extension.

HeaderSignature$ = Chr$( 208 ) & Chr$( 207 ) & Chr$( 17 ) & Chr$( 224 ) & Chr$( 161 ) & Chr$( 177 ) & Chr$( 26 ) & Chr$( 225 )

' Find the path to OCLC's "Macros" folder and make an array of the macro books it
' contains to display in a drop list box in the dialog box. Also build a string of macro
' book names, along with file modification dates, for saving.

ReDim MacroBooks( FileCounter% )
MacroBooks( FileCounter% ) = "Select a macro book:"
FileCounter%               = FileCounter% + 1
Call GetEnviroVars
MacroDirectoryPath$        = ProgramFilesPath$ & MacroDirectoryPath$
MacroDirectoryFiles$       = MacroDirectoryPath$ & "*.mbk"
MacroBookFile$             = Dir( MacroDirectoryFiles$ )
MacroBookList$             = ""

Do While MacroBookFile$ <> ""
  Possibility$   = MacroDirectoryPath$ & MacroBookFile$
  FileNumber%    = Freefile
  Open Possibility$ For Binary As #FileNumber%
  Get #FileNumber%, , First8Bytes
  Close #FileNumber%
  Reset
  If First8Bytes = HeaderSignature$ Then
      MacroBookName$             = Left$( MacroBookFile$, Len( MacroBookFile$ ) - FILE_EXTENSION% )
      ReDim Preserve MacroBooks( FileCounter% )
      MacroBooks( FileCounter% ) = MacroBookName$
      MacroBookList$             = MacroBookList$ & MacroBookName$ & TabChar$ & FileDateTime( Possibility$ ) & CR$
      FileCounter%               = FileCounter% + 1
  End If
  MacroBookFile$ = Dir
Loop
MacroBookList$ = Left$( MacroBookList$, Len( MacroBookList$ ) - 2 )

End Sub

'****************************************************************************************

Sub GetMacroInfo( MacroDirectoryInfo$ )

' This subprogram gets the text (source data) of the selected macro. This supplies a line
' count, which gives an idea of the size of the macro, and also enables some checking of
' the integrity of the macro. The first 25 lines are examined to look for a revision
' date, and are stored (up to 1024 bytes) to display in a dialog box.

Dim LineBegin$
Dim LineFound%
Dim LinesShown$
Dim MacroChunks%
Dim MacroLine$
Dim MacroLineLength%
Dim Start%
Dim StringToCheck$
Dim TestDesc$
Dim TextDesc$
Dim TextName$

Dim MaxPreview               : MaxPreview  = FALSE

Dim i As Integer, p As Integer, x As Integer

LineCount&         = 0
MacroRevisionDate$ = ""
MatchCache$        = " "
MatchWarning$      = ""
PreviewLines$      = ""
TestString$        = "0000 "

DifferentDesc      = FALSE

FirstSector& = Val( Mid$( MacroDirectoryInfo$, OFFSET_FIRST_SECTOR, DATA_SUBSTRING_8 ) )
StreamSize&  = Val( Mid$( MacroDirectoryInfo$, OFFSET_SRC_LEN, DATA_SUBSTRING_8 ) )

' Build the macro.

If StreamSize& < MAX_SIZE_MINISTREAM Then
    Call BuildDataStream( FirstSector&, MINI_C, StreamSize& )
  Else
    Call BuildDataStream( FirstSector&, MAIN_C, StreamSize& )
End If

Call StoreWithTerminator( STREAM_DATA% )

' Read and count the lines in the macro. (A line is defined as text between two carriage
' return/line feed combinations, that is, a string of characters with the character pair
' "[CR][LF]" or "0D0A" at each end. Connexion macros also work with only a line feed
' character ("0A") as a line terminator. However, I have chosen not to try to make this
' macro able to deal with both styles of line ending; thus macros lacking carriage
' returns ("0D") won't have their information display properly.) The line count gives an
' idea of the size of the macro. As lines are counted and read, check:
'  1) that the macro name in the source code matches what is in the directory;
'  2) that the first line of the macro description in the source code matches what was
'     entered in the macro manager (subsequent lines used for a lengthier description
'     have to be ignored);
'  3) in the first 25 lines, for a possible revision date;
'  4) throughout, for matching subroutine openings and closings.
' Store the first 25 lines, or 1024 bytes (whichever comes first), for display.

MacroChunks% = UBound( EndWithLF)
For i = 0 To MacroChunks%
  StringToCheck$ = EndWithLF( i )
  Start% = 1
  Do
    LineFound% = InStr( Start%, StringToCheck$, CR$ )
    If LineFound% <> 0 Then
        LineCount& = LineCount& + 1
        MacroLine$ = Mid$( StringToCheck$, Start%, LineFound% - Start% )
        MacroLineLength% = Len( MacroLine$ )
        If LineCount& < 26 Then
            If MaxPreview = FALSE Then
                If Len( PreviewLines$ ) + MacroLineLength% < 1024 Then
                    PreviewLines$ = PreviewLines$ & MacroLine$ & CR$
                    LinesShown$   = Trim$( Str$( LineCount& ) )
                  Else
                    PreviewLines$ = Left$( PreviewLines$, Len( PreviewLines$ ) - 1 )
                    MaxPreview    = TRUE
                End If
            End If
        End If
        If MacroLineLength% > 0 Then
            If Left$( MacroLine$, 1 ) = SingleQuote$ Then
                If LineCount& < 26 Then
                    If TextName = "" Then

' Look for the macro name, which must appear exactly as the macro editor enters it (that
' is, the line must be a comment line, and the macro's name must follow the text
' "MacroName:"), and check it against the macro name as stored in the directory and
' displayed in the macro manager.

                        p = InStr( MacroLine$, "MacroName:" )
                        If p <> 0 Then
                            p = p + 9
                            If MacroLineLength% > p Then
                                TextName$ = Trim$( Mid$( MacroLine$, p + 1 ) )
                                If TextName$ <> SelectedMacroName$ Then
                                    SourceName$ = TextName$
                                  Else
                                    SourceName$ = ""
                                End If
                              Else
                                SourceName$ = ""
                                TextName$   = "[NOT FOUND]"
                            End If
                        End If
                    End If

' Also look for the macro description, and check it against the description stored in the
' macro's ".DES" stream (the text entered in the macro manager). As with the name, the
' description must appear in a comment line. The description entered here may be
' formatted so it spans multiple lines, but the macro can't tell which might be the last
' line; therefore, only the first line is considered. If this first line does not match
' the official description, a flag is set to display a warning. If a mismatch occurs
' after the first line of the description, the macro can't detect that.

                    If TextDesc$ = "" Then
                        p = InStr( MacroLine$, "MacroDescription:" )
                        If p <> 0 Then
                            p = p + 16
                            If MacroLineLength% > p Then
                                TextDesc$ = Trim$( Mid$( MacroLine$, p + 1 ) )
                                TestDesc$ = Trim$( Mid$( MacroDirectoryInfo$, OFFSET_DESC ) )
                                If TextDesc$ = "" And TestDesc$ = "" Then
                                    DifferentDesc = FALSE
                                  ElseIf TextDesc$ = "" And TestDesc$ <> "" Then
                                    DifferentDesc = TRUE
                                  ElseIf TextDesc$ <> "" And TestDesc$ = "" Then
                                    DifferentDesc = TRUE
                                  Else
                                    If TestDesc$ <> "[NO DESCRIPTION PROVIDED]" Then
                                        x = InStr( 1, TestDesc$, TextDesc$, 0 )
                                        If x = 0 Then
                                            DifferentDesc = TRUE
                                          Else
                                            DifferentDesc = FALSE
                                        End If
                                    End If
                                End If
                              Else
                                TextDesc$ = "[NOT FOUND]"
                            End If
                        End If
                    End If

' Check for a revision date.

                    If MacroRevisionDate$ = "" Then
                        If LineCount& > 2 Then
                            MacroRevisionDate$ = FindRevisionDate( MacroLine$ )
                        End If
                    End If
                End If
              Else

' Check for matching subroutine and function calls and ends.

                LineBegin$ = LCase$( Left$( Trim$( MacroLine$ ), 4 ) )
                If LineBegin$ = "end " Or LineBegin$ = "sub " Or LineBegin$ = "func" Or LineBegin$ = "priv" Or LineBegin$ = "stat" Then
                    If MatchWarning$ = "" Then
                        MatchWarning$ = MatchCalls( MacroLine$, LineCount& )
                    End If
                End If
            End If
        End If
    End If
    Start% = LineFound% + 2
  Loop While LineFound% > 0
Next i

' Format a message to state how many lines of the macro are being displayed in the
' preview box.

If LineCount& < 26 Then
    LineCountReport$ = "Complete macro:"
  Else
    LineCountReport$ = "First " & LinesShown$ & " lines of macro:"
End If

' Format the lines showing the size of the macro.

LineCountStr = "Number of lines in macro: " & Trim$( Str$( LineCount& ) )
MacroSizeStr = "Size of macro source/binary: " & Trim$( Str$( StreamSize& ) ) & "/"

' Format the revision date statement.

If MacroRevisionDate$ = "" Then
    MacroRevisionDate$ = "[No revision date found]"
  Else
    MacroRevisionDate$ = DoubleQuote$ & MacroRevisionDate$ & DoubleQuote$
End If

' If the last called "Sub" or "Function" was not closed:

Select Case Left$( MatchCache$, 1 )
  Case "S"
    MatchWarning$ = DoubleQuote$ & "Sub" & DoubleQuote$ & " called on line " & Mid$( MatchCache$, 2 ) & ", but no " & DoubleQuote$ & "End Sub" & DoubleQuote$ & " was found."
  Case "F"
    MatchWarning$ = DoubleQuote$ & "Function" & DoubleQuote$ & " called on line " & Mid$( MatchCache$, 2 ) & ", but no " & DoubleQuote$ & "End Function" & DoubleQuote$ & " was found."
End Select

If MatchWarning$ <> "" Then
    MatchWarning$ = "Probably corrupt macro! " & MatchWarning$
End If

End Sub

'****************************************************************************************

Sub GetMacroNames

' This subprogram runs through all the directory entries previously extracted to get the
' macro names, which it pulls out, along with information about each macro.

Const DIR_ENTRY_NAME_LENGTH As Integer = 65   'The location of the value for the length of a directory entry name.
Const OBJECT_TYPE           As Integer = 67   'The location of the value of a type of object (0, 1, 2, or 5).
Const STREAM_SIZE           As Integer = 121  'The size of the user-defined data, if this is a stream object.
Const VALID_STREAM          As Integer = 2    'The value for a valid stream object in a directory entry.

Dim DirectoryEntry$
Dim DirEntryCount%
Dim DirEntryName$
Dim DirName$
Dim FirstSectorStr As String*DATA_SUBSTRING_8
Dim LenDirEntryName%
Dim MacroDescription$
Dim MacroName$
Dim NameChar%
Dim StreamSizeStr As String*DATA_SUBSTRING_8
Dim TypeOfDirEntry%

For DirEntryCount% = 0 To UBound( DirectoryEntries )
  DirectoryEntry$ = DirectoryEntries( DirEntryCount% )
  TypeOfDirEntry% = CInt( HexVal( Mid$( DirectoryEntry$, OBJECT_TYPE, 1 ) ) )

' Only valid entries referring to stream objects are needed. Other entries, if present,
' are ignored, and data in the root directory entry have already been obtained. For each
' entry, get the name and convert it to ASCII (i.e., strip it of null characters). Also
' get the sector number of the beginning of the associated data stream and its length.

  If TypeOfDirEntry% = VALID_STREAM Then
      LenDirEntryName% = CInt( HexVal( Mid$( DirectoryEntry$, DIR_ENTRY_NAME_LENGTH, 2 ) ) )
      DirEntryName$    = Left$( DirectoryEntry$, LenDirEntryName% )
      DirName$         = ""
      For NameChar% = 1 To Len( DirEntryName$ ) - 2 Step 2
        DirName$ = DirName$ & Mid$( DirEntryName$, NameChar%, 1 )
      Next NameChar%
      DirName$         = Trim$( DirName$ )
      FirstSector&     = HexVal( Mid$( DirectoryEntry$, STREAM_START, DWORD ) )

' The stream size field is eight bytes, containing a 64-bit integer. However, in this
' version (3) of the compound file format, the most significant 32 bits must be zero,
' and can be ignored. Therefore, read only the first four bytes (a double word) of the
' field to get the size of the data stream.

      StreamSize&      = HexVal( Mid$( DirectoryEntry$, STREAM_SIZE, DWORD ) )

' Convert the starting sector ID and the stream size to a string to pass along.

      FirstSectorStr   = Trim$( Str$( FirstSector& ) )
      StreamSizeStr    = Trim$( Str$( StreamSize& ) )
      Select Case Right$( DirName$, 3 )

' Each macro appears within the file in three streams, represented in the directory with
' the macro name to which the extensions ".SRC," ".DES," and ".BIN" have been appended.
' The directory entries for the first two streams contain information to asemble the text
' of the macro and the macro description, respectively. To prepare the entries for the
' list of macros, data from the three streams must be isolated and then merged. After
' identifying the stream by the extension, strip the extension from the macro name, and
' add appropriate values from the directory entry. For the ".SRC" entry, add the ID of
' the first sector of the source data, and the stream length of that data, as 8-character
' strings; if they are needed to display the source code, the strings will be converted
' back to numbers later. The result will be a string of 44 characters.

        Case "SRC"
          MacroName$ = Left$( DirName$, Len( DirName$ ) - FILE_EXTENSION% )
          MacroName$ = MacroName$ & Space$( MAX_LEN_MACRO_NAME - Len( MacroName$ ) ) & FirstSectorStr & StreamSizeStr

' Extract also the name from the ".DES" stream, but to it add a blank string of 24
' spaces. Use the directory entry data to get the description (if any) from the
' Ministream, and add that, or else a note about the description not being found, to the
' end of the string, starting at position 53.

        Case "DES"
          MacroName$ = Left$( DirName$, Len( DirName$ ) - FILE_EXTENSION% )
          If FirstSector& > END_OF_CHAIN Then
              Call BuildDataStream( FirstSector&, MINI_C, StreamSize& )
              MacroDescription$ = DataStream( 0 )
            Else
              MacroDescription$ = "[NO DESCRIPTION PROVIDED]"
          End If
          MacroName$ = MacroName$ & Space$( OFFSET_DESC - 1 - Len( MacroName$ ) ) & MacroDescription$

' For the ".BIN" stream, after Dialog2Definition the name, add only the length of the stream
' that contains the compiled binary, resulting in a string of 36 characters.

        Case "BIN"
          MacroName$ = Left$( DirName$, Len( DirName$ ) - FILE_EXTENSION% )
          MacroName$ = MacroName$ & Space$( MAX_LEN_MACRO_NAME - Len( MacroName$ ) ) & StreamSizeStr
      End Select

' Send the newest macro name to the subprogram for insertion or merging into the list of
' macros.

      Call SortMacroNames( MacroName$ )

  End If
Next DirEntryCount%

End Sub

'****************************************************************************************

Sub MakeMacroList( SelectedMbkFile$ )

' This subprogram extracts information required for constructing the list of macros in
' the selected macro book. That information is also used by other subprograms to display
' information about individual macros.

' These constants are offsets in the file (character offsets, starting at 1).

Const DIRECTORY_STREAM_START As Integer = 49   'The starting sector number for the directory stream.
Const FAT_DIRECTORY          As Integer = 77   'The first 109 FAT sector locations of the compound file.
Const FAT_SECTOR_COUNT       As Integer = 45   'The count of the number of FAT sectors in the compound file.
Const HEADER_SECTOR_ID       As Long    = -1&  'The ID of the sector that precedes sector 0.
Const MINI_FAT_SECTOR_COUNT  As Integer = 65   'The count of the number of mini FAT sectors in the compound file.
Const MINI_FAT_START         As Integer = 61   'The starting sector number for the mini FAT.

Dim FileHeader$
Dim FirstSectorOfDirectory&
Dim FirstSectorOfMiniFAT%
Dim MacroListString$
Dim MinistreamStart&
Dim NextMiniSecData$
Dim RootStorageEntry$
Dim TotalSectorsInFAT%
Dim TotalSectorsInMiniFAT%

Dim i As Integer

' Get important values from the Header and the Directory.

FileHeader$             = GetSectorData( HEADER_SECTOR_ID, MAIN_C )

' FAT information:
TotalSectorsInFAT%      = CInt( HexVal( Mid$( FileHeader$, FAT_SECTOR_COUNT, DWORD ) ) )
FATSectorListInHeader$  = Mid$( FileHeader$, FAT_DIRECTORY, 436 )

' Directory information:
FirstSectorOfDirectory& = HexVal( Mid$( FileHeader$, DIRECTORY_STREAM_START, DWORD ) )
RootStorageEntry$       = Left$( GetSectorData( FirstSectorOfDirectory&, MAIN_C ), DIR_ENTRY_LENGTH )
MinistreamStart&        = HexVal( Mid$( RootStorageEntry$, STREAM_START, DWORD ) )

' MiniFAT information:
FirstSectorOfMiniFAT%   = CInt( HexVal( Mid$( FileHeader$, MINI_FAT_START, DWORD ) ) )
TotalSectorsInMiniFAT%  = CInt( HexVal( Mid$( FileHeader$, MINI_FAT_SECTOR_COUNT, DWORD ) ) )

' Build the two FATs, the Ministream, and the Directory entries array.

BeginBF#  = Timer
Call BuildFAT( TotalSectorsInFAT% )
FinishBF# = Timer
TimeBF$   = FormatDuration( BeginBF#, FinishBF# )

BeginBMF#  = Timer
Call BuildMiniFAT( TotalSectorsInMiniFAT%, FirstSectorOfMiniFAT% )
FinishBMF# = Timer
TimeBMF$   = FormatDuration( BeginBMF#, FinishBMF# )

If MinistreamStart& > END_OF_CHAIN Then
    BeginBMS#   = Timer
    Call BuildMinistream( MinistreamStart& )
    FinishBMS#  = Timer
    TimeBMS$    = FormatDuration( BeginBMS#, FinishBMS# )
End If

Call GetDirectoryEntries( FirstSectorOfDirectory& )

' Build the array of macro names.

BeginDS# = Timer

MacroCount% = 0

Call GetMacroNames

TotalMacroCount% = UBound( MacroListPlus )

' Cleanup of the macro name array: Sometimes an extra, empty element will be present at
' the end; remove it.

Do
  If MacroListPlus( TotalMacroCount% ) = "" Then
      ReDim Preserve MacroListPlus( TotalMacroCount% - 1 )
      TotalMacroCount% = UBound( MacroListPlus )
    Else
      Exit Do
  End If
Loop Until UBound( MacroListPlus ) = 0

' Prepare values for the dialog box. First, reDim the link array to the number of macros
' in the book.

ReDim LinkingArray( TotalMacroCount%, 1 )

' Set the text for the count of macros.

If TotalMacroCount% = 0 Then
    SummaryMacroCount$ = "One macro:"
  Else
    SummaryMacroCount$ = Trim$( Str$( TotalMacroCount% + 1 ) ) & " macros:"
End If

' The display list is the names only, shorn of the other data.

For i = 0 To TotalMacroCount%
  ReDim Preserve MacroListNames( i )
  MacroListNames( i ) = Trim$( Left$( MacroListPlus( i ), MAX_LEN_MACRO_NAME ) )
Next i

FinishDS# = Timer
TimeDS$   = FormatDuration( BeginDS#, FinishDS# )

' Place the list on the clipboard.

MacroListString$ = "Macro book name: " & MacroBookName$ & CR$
For i = 0 To TotalMacroCount%
  MacroListString$ = MacroListString$ & MacroListNames( i ) & CR$
Next i
MacroListString$ = Left$( MacroListString$, Len( MacroListString$ ) - 2 )
Clipboard.Clear
Clipboard.SetText MacroListString$

End Sub

'****************************************************************************************

Sub ReadFile( FileName$ )

' This subprogram reads the file whose name is passed to it and stores the data in a
' string array for the rest of the macro.

Dim CountFileSections%
Dim FileDivider&
Dim FileEnd$
Dim FileNumber%
Dim FileSectionRead As String*MAX_STRING_LENGTH
Dim Remainder%
Dim TotalFileSections%

FileNumber% = Freefile

' Open the selected file. Because of the limitations on string length in OCLC's version
' of BASIC, the file can only be read in chunks of about 32K bytes, so the macro may
' have to loop through it several times to read it all. The chunk size is set at 31744
' bytes, the largest multiple of 512 (the expected sector size) to fit safely under the
' limit.

Open FileName$ For Binary As #FileNumber%
FileSize&          = FileLen( FileName$ )
TotalFileSections% = Int( FileSize& / MAX_STRING_LENGTH )
Remainder%         = FileSize& Mod MAX_STRING_LENGTH
FileDivider&       = 1&
CountFileSections% = 0

' Read the file, storing it in a string array whose elements are of maximum length 31744
' (62 sectors).

If TotalFileSections% > 0 Then
    For CountFileSections% = 1 To TotalFileSections%
      Get #FileNumber%, FileDivider&, FileSectionRead
      ReDim Preserve FileSections( CountFileSections% - 1 )
      FileSections( CountFileSections% - 1 ) = FileSectionRead
      FileDivider& = FileDivider& + MAX_STRING_LENGTH
    Next CountFileSections%
End If
If Remainder% > 0 Then
    Get #FileNumber%, FileDivider&, FileSectionRead
    FileEnd$ = Left$( FileSectionRead, Remainder% )
    If CountFileSections% > 0 Then
        CountFileSections% = CountFileSections% - 1
    End If
    ReDim Preserve FileSections( CountFileSections% )
    FileSections( CountFileSections% ) = FileEnd$
End If

Close #FileNumber%
Reset

End Sub

'****************************************************************************************

Sub ShowTimes

' This subprogram displays time elapsed for the various routines of the macro.

Dim ProcRate!
Dim ProcRateStr$
Dim TotalString$             : TotalString$ = "Total time to build macro list: " & TimeMML$

ProcRate!    = Format( FileSizeKB% / Val( TimeMML$ ), "#.##" )
ProcRateStr$ = Trim$( Str$( ProcRate! ) )

Begin Dialog Dialog2Definition 168, 172, WaltsMacros$
  OkButton       28, 140,  48, 16
  CancelButton   92, 140,  48, 16
  Text           16,   8, 128,  8, "All times given in seconds."
  GroupBox       16,  22, 136, 58, TotalString$
  Text           26,  34,  80,  8, "Time to build FAT:"
  Text          114,  34,  36,  8, TimeBF$
  Text           26,  44,  80,  8, "Time to build MiniFAT:"
  Text          114,  44,  36,  8, TimeBMF$
  Text           26,  54,  80,  8, "Time to build Ministream:"
  Text          114,  54,  36,  8, TimeBMS$
  Text           26,  64,  80,  8, "Time to sort list of names:"
  Text          114,  64,  36,  8, TimeDS$
  Text           16,  86,  82,  8, "Time to build macro data:"
  Text          104,  86,  60,  8, TimeGMI$
  Text           16, 100,  60,  8, "Number of macros:"
  Text          104, 100,  24,  8, Trim$( Str$( TotalMacroCount% + 1 ) )
  Text           16, 110,  60,  8, "File size in KB:"
  Text          104, 110,  48,  8, FileSizeKBStr$
  Text           16, 120,  84,  8, "KB processed per second:"
  Text          104, 120,  48,  8, ProcRateStr$
End Dialog

Dim Dialog2 As Dialog2Definition
On Error Resume Next
Dialog Dialog2

End Sub

'****************************************************************************************

Sub SortMacroNames( NewestName$ )

' This subprogram builds the master array of unique macro names, alphabetizing it along
' the way. It compares each new macro name to the other names in the array (disregarding
' case, although it probably doesn't matter--but why is the ".BIN" name sometimes in
' inverted case?). It starts with the previous name added, as most often the three
' entries, ".SRC", ".DES", and ".BIN", come in trios (although the order in which they
' appear in the directory is unpredictable). If the names are the same, the routine
' merges the entries; otherwise, it either goes back to the first entry or on to the next
' one, and then compares the incoming macro name to each subsequent entry in the array
' until its proper place is found and it is inserted. Note that corrupted macros may
' still have valid directory entries and thus will be added to this list.

Const BIN_ENTRY     As Integer = 36  'The length of the macro name string from the ".BIN" stream.
Const BIN_SRC_ENTRY As Integer = 52  'The length of the string resulting from merging the ".BIN" and ".SRC" streams.
Const SRC_ENTRY     As Integer = 44  'The length of the macro name string from the ".SRC" stream.

Dim Existing$
Dim Incoming$
Dim Incumbent$
Dim Start%

Dim j As Integer, k As Integer

' For sorting, consider only the leftmost 28 characters.

Incoming$ = Trim$( Left$( NewestName$, MAX_LEN_MACRO_NAME ) )

ReDim Preserve MacroListPlus( MacroCount% )
If MacroCount% = 0 Then

' The very first name is added without any more ado.

    MacroListPlus( MacroCount% ) = NewestName$
    PreviousEntry% = 0

' For the second and subsequent entries in the array, the new name is compared to the
' previously added name. If it is the same, their information is merged; if not, this
' step may reduce the sorting time, as it may be appropriate to start comparison with the
' other entries in the array from the next entry, rather than starting at 0.

  Else
    Existing$ = Trim$( Left$( MacroListPlus( PreviousEntry% ), MAX_LEN_MACRO_NAME ) )
    Select Case StrComp( Incoming$, Existing$ )
      Case STRING1_LESS_THAN   'new name less than last name added: start comparing at entry 0 in array.
        Start% = 0
      Case Else               'otherwise, start comparing with last name added.
        Start% = PreviousEntry%
    End Select
    For j = Start% To MacroCount%
      Incumbent$ = MacroListPlus( j )
      Existing$  = Trim$( Left$( Incumbent$, MAX_LEN_MACRO_NAME ) )
      Select Case StrComp( Incoming$, Existing$ )

' If the two names are identical (except for capitalization), merge them. The final
' result of merging will be a single element of a string array that contains information
' about each macro, some for display, some for further calculation. This string consists
' of five elements, positionally defined:
'   characters  1-28  the macro name
'              29-36  the sector number of the beginning of the macro source text
'              37-44  the length of the data stream of the source text
'              45-52  the length of the data stream of the compiled binary code
'              53-    the macro description
' In the merge process, always replace (or simply don't add) the ".BIN" name as its case
' may not be correct, but keep the length of its data stream as the fourth element in the
' string. Otherwise, data may be added to the ".SRC" string or inserted into the ".DES"
' string. Distinguish between the different strings by their lengths, which are constant.
' Don't increase the count of macros for a replacement!

        Case STRING1_EQUAL_TO

          Select Case Len( Incumbent$ )   'The existing entry in the array is identified by its length

            Case BIN_ENTRY                 'Always replace an existing ".BIN" name
              If Len( NewestName$ ) = SRC_ENTRY Then
                  MacroListPlus( j ) = NewestName$ & Right$( Incumbent$, DATA_SUBSTRING_8 )
                Else
                  MacroListPlus( j ) = Left$( NewestName$, SRC_ENTRY ) & Right$( Incumbent$, DATA_SUBSTRING_8 ) & Mid$( NewestName$, OFFSET_DESC )
              End If

            Case SRC_ENTRY
              If Len( NewestName$ ) = BIN_ENTRY Then
                  MacroListPlus( j ) = Incumbent$ & Right$( NewestName$, DATA_SUBSTRING_8 )
                Else
                  MacroListPlus( j ) = Incumbent$ & "        " & Mid$( NewestName$, OFFSET_DESC )
              End If

            Case BIN_SRC_ENTRY
              MacroListPlus( j ) = Incumbent$ & Mid$( NewestName$, OFFSET_DESC )

            Case Else
              If Len( NewestName$ ) = BIN_ENTRY Then
                  MacroListPlus( j ) = Left$( Incumbent$, SRC_ENTRY ) & Right$( NewestName$, DATA_SUBSTRING_8 ) & Mid$( Incumbent$, OFFSET_DESC )
                Else
                  MacroListPlus( j ) = NewestName$ & Mid$( Incumbent$, OFFSET_BIN_LENGTH )
              End If

          End Select

          MacroCount%    = MacroCount% - 1
          PreviousEntry% = j
          Exit For

' If the newest macro name files before the one in this position in the array, insert it,
' bumping all subsequent names one position toward the end.

        Case STRING1_LESS_THAN
          For k = MacroCount% To j + 1 Step -1
            MacroListPlus ( k ) = MacroListPlus( k - 1 )
          Next k
          MacroListPlus( j ) = NewestName$
          PreviousEntry%     = j
          Exit For

' If the newest macro name files after the one with which it has just been compared,
' recycle to continue comparing--unless the end of the array has been reached, in which
' case the name is simply added.

        Case STRING1_GREATER_THAN
          If j = MacroCount% Then
              MacroListPlus( MacroCount% ) = NewestName$
              PreviousEntry%               = j
          End If

      End Select

    Next j
End If

MacroCount% = MacroCount% + 1

End Sub

'****************************************************************************************

Sub StoreWithTerminator( WhichArray% )

' Since the routines that look for shortcut keys or user tool assignments depend on
' finding line terminators, this subprogram adjusts the elements of the storage array so
' each one ends with ASCII 10, the line feed character.

Dim CurrString$
Dim PrevString$
Dim TempString$
Dim TestChar%

Dim i As Integer, j As Integer, n As Integer, x As Integer, y As Integer, z As Integer

Dim TempStorage() As String

If WhichArray% = 0 Then      'DataStream
    For i = 0 To UBound( DataStream )
      ReDim Preserve TempStorage( i )
      TempStorage( i ) = DataStream( i )
    Next i
  Else                       'File stream
    For i = 0 To UBound( FileSections )
      ReDim Preserve TempStorage( i )
      TempStorage( i ) = FileSections( i )
    Next i
End If

i = 0 : n = 0

Do
  CurrString$ = TempStorage( i )
  x = Len( CurrString$ )
  y = Len( PrevString$ )
  If x + y >= MAX_STRING_LENGTH Then
      z = MAX_STRING_LENGTH - y
      For j = z To 1 Step -1
        TestChar% = Asc( Mid$( CurrString$, j, 1 ) )
        If TestChar% = 10 Then
            Exit For
        End If
      Next j
      If j = 0 Then
          TempString$ = PrevString$
          PrevString$ = ""
          i           = i - 1
        Else
          TempString$ = PrevString$ & Left$( CurrString$, j )
          PrevString$ = Mid$( CurrString$, j + 1 )
      End If
    Else
      TempString$ = PrevString$ & CurrString$
  End If
  ReDim Preserve EndWithLF( n )
  EndWithLF( n ) = TempString$
  n = n + 1
  i = i + 1
Loop Until i > UBound(TempStorage)

End Sub

'****************************************************************************************

Sub WriteFile( SaveType% )

' This is the writing subprogram. After receiving the desired file name, it checks for
' the existence of that file, asking for confirmation of an overwrite. It writes data to
' the file according to what the data is. A list is prefixed with a header of a few lines
' containing a date of file production and other data; a macro's text has a footer with
' that same information. Tabs are used to separate macro names and descriptions, as well
' as to separate macro book file names and date/time of modification of those files.

Const INFORMATION_MESSAGE As Integer = 64  'The value to display the "Information message" icon in a message box.

Dim Answer%
Dim Attributes%
Dim CharT$
Dim Credit$        'shameless self-promotion
Dim CurrentDirectory$
Dim DateString$
Dim Drive$
Dim FileAttributes%
Dim FileWrite%
Dim Legend$
Dim NewDir$
Dim Start%
Dim TempString$

Dim i as Integer, p As Integer

Credit$ = " using " & DoubleQuote$ & "MacroBookInspector" & DoubleQuote$ & " macro by Walter F. Nickeson."

' Since OML can't present a typical Save dialog, the next best thing is to offer a string
' that might need no, or only a little, editing to specify the file location. The first
' time the Save sub is called, the default save file name and path (defined on line 284
' above) is offered. On subsequent Saves, the last used path is the basis on which to
' build the complete file name. The previous path is constructed by removing the last
' element (the file name).

If SaveCount% > 0 Then
    TempString$ = PreviousSaves( 0 )
    For i = Len( TempString$ ) To 1 Step -1
      CharT$ = Mid$( TempString$, i, 1 )
      If CharT$ = "\" Then
          DefaultSavePath$ = Left$( TempString$, i )
          Exit For
      End If
    Next i
End If

' The default file name is the default directory path plus either the macro book name or
' the macro name, with the appropriate suffix.

If SaveType% = SAVE_LIST Then
    Legend$       = "Save list as:"
    SaveFileName$ = DefaultSavePath$ & MacroBookName$ & ".mbk.txt"
  Else
    Legend$       = "Save text of macro as:"
    SaveFileName$ = DefaultSavePath$ & SelectedMacroName$ & ".txt"
End If

Redo:

PreviousSaves( 0 ) = SaveFileName$

Begin Dialog Dialog3Definition  320, 58, WaltsMacros$, .Dialog3ControlFunction
  OkButton      260, 36,  52, 14
  CancelButton  200, 36,  52, 14
  PushButton      8, 36,  52, 14, "Clear",         .Clear
  DropComboBox    8, 16, 304, 64, PreviousSaves(), .ComboBox
  Text            8,  6, 256,  8, Legend$
End Dialog

Dim Dialog3 As Dialog3Definition
On Error Resume Next
Dialog Dialog3
If Err = 102 Then Exit Sub

SaveFileName$ = Trim$( Dialog3.ComboBox)

' On the assumption that subsequent Saves will take place in the same location, use the
' last save path as the basis for the new default location. Put the actual path entered
' in the dialog box into the first element of the array, pushing every previous element
' (if any) up one slot to leave an open first element for the next Save. That will be
' filled the next time around before the dialog box appears.

PreviousSaves( 0 ) = SaveFileName$
SaveCount%         = SaveCount% + 1
ReDim Preserve PreviousSaves( SaveCount% )
For i = UBound( PreviousSaves ) To 0 Step -1
  PreviousSaves( i ) = PreviousSaves( i - 1 )
Next i

' Check to see if the file exists.

On Error Resume Next
FileAttributes% = GetAttr( SaveFileName$ )
Select Case Err
  Case 53

' If the file does not exist, it can be created. But first check that the directory
' structure is in place to receive it. Note that "MkDir" cannot create subdirectories
' more than one level below the parent. If the path given to the function has more
' levels, this loop adds one subdirectory at a time, then changes the default directory
' to the newly added subdirectory. Repeat as necessary.

    For i = Len( SaveFileName$ ) To 1 Step -1
      CharT$ = Mid$( SaveFileName$, i, 1 )
      If CharT$ = "\" Then
          NewDir$ = Left$( SaveFileName$, i - 1 )
          Attributes% = GetAttr( NewDir$ )
          If Attributes% <> 16 Then
              Answer% = MsgBox( "The path " & DoubleQuote$ & NewDir$ & DoubleQuote$ & " does not exist! Create new directories?", 35, WaltsMacros$ )
              Select Case Answer
                Case 2
                  Exit Sub
                Case 6
                  Exit For
                Case 7
                  GoTo Redo:
              End Select
            Else
              Exit For
          End If
      End If
    Next i
    CurrentDirectory$ = CurDir$
    Start%            = 1
    Do
      p = InStr( Start%, SaveFileName$, "\" )
      If p <> 0 Then
          If Start% = 1 Then

' If an incorrect drive is specified, this sub can't proceed.

              Drive$      = Left$( SaveFileName$, p )
              Attributes% = GetAttr( Drive$ )
              If Attributes% <> 16 And Attributes% <> 22 And Attributes% <> 48 Then
                  MsgBox "Please enter a valid filename with complete path!", WARNING_MESSAGE, WaltsMacros$
                  Exit Sub
              End If
            Else
              NewDir$     = Left$( SaveFileName$, p - 1 )
              Attributes% = GetAttr( NewDir$ )
              If Attributes% <> 16 Then
                  MkDir NewDir$
              End If
              ChDir NewDir$
          End If
        Else
          ChDir CurrentDirectory$
      End If
      Start% = p + 1
    Loop Until p = 0
  Case 52, 64
    MsgBox "Please check the file name!", WARNING_MESSAGE, WaltsMacros$
    Exit Sub
  Case 61
    MsgBox "Sorry, there is no more room on the disk!", WARNING_MESSAGE, WaltsMacros$
    Exit Sub
  Case 68, 71
    MsgBox "Sorry, the device is unavailable!", WARNING_MESSAGE, WaltsMacros$
    Exit Sub
  Case Else     'File exists; confirm replacement
    If FileAttributes% < 8 Or FileAttributes% > 16 Then
        Answer% = MsgBox( "Replace existing file?", 35, WaltsMacros$ )
        If Answer% = 6 Then
            Kill SaveFileName$
          Else
            Exit Sub
        End If
    End If
End Select

DateString$ = Date$ & " " & Time$
DateString$ = Format( DateString$, "General Date" )
FileWrite%  = FreeFile
Open SaveFileName$ For Output As #FileWrite%

If SaveType% = SAVE_LIST Then
    Print #FileWrite%, "Macros in macro book: " & MacroBookName$
    Print #FileWrite%, "File: " & MacroBookFile$
    Print #FileWrite%, FileInfo$
    Print #FileWrite%,
    Print #FileWrite%, "List created " & DateString$ & Credit$
    Print #FileWrite%,
    Print #FileWrite%, SummaryMacroCount$
    For i = 0 To UBound( MacroListPlus )
      TempString$ = MacroListPlus( i )
      Print #FileWrite%, Trim$( Left$( TempString$, MAX_LEN_MACRO_NAME ) ) & TabChar$ & Trim$( Mid$( TempString$, OFFSET_DESC ) )
    Next i
  Else
    For i = 1 To UBound( MasterMacroArray, 2 )
      TempString$ = MasterMacroArray( SelectedMacroIndex%, i )
      If TempString$ <> "" Then
          Print #FileWrite%, TempString$;
      End If
    Next i
    Print #FileWrite%, SingleQuote$
    Print #FileWrite%, SingleQuote$ & "Macro name: " & SelectedMacroName$
    Print #FileWrite%, SingleQuote$ & "Macro book: " & MacroBookFile$
    Print #FileWrite%, SingleQuote$ & "Saved: " & DateString$ & Credit$
End If

Close FileWrite%
Reset

FileAttributes% = -1
FileAttributes% = GetAttr( SaveFileName$ )
If FileAttributes% = -1 Then
    MsgBox "Sorry, the file could not be created.", WARNING_MESSAGE, WaltsMacros$
  Else
    If SaveType% = SAVE_LIST Then
        MsgBox "List of macros saved.", INFORMATION_MESSAGE, WaltsMacros$
      Else
        MsgBox "Text of macro saved.",  INFORMATION_MESSAGE, WaltsMacros$
    End If
End If

End Sub

'****************************************************************************************

Function FindRevisionDate( MacroLine$ ) As String

' This function attempts to find a date of revision in the first 25 lines of a macro.

Const STRING_CHOMPER As Integer = 8  'Cuts off a string that might be too long.

Dim DateFound$
Dim FirstChar%
Dim RevDate%
Dim RevWord%
Dim TempString$

Dim j As Integer, k As Integer

TempString$ = MacroLine$

For j = 0 To UBound( UpdateDate )
  RevDate% = InStr( TempString$, UpdateDate( j ) )
  If RevDate% <> 0 Then

' If a date (that is, a year; searching for month and date also would be a big task and
' so is not implemented here) is found, isolate it for easier comparison. Compare it with
' any date found in a previous line and discard the earlier date (that is, earlier in
' terms of the year; assume that the same year found on a later line represents a later
' revision).

      DateFound$ = Mid$( TempString$, RevDate%, 4 )
      If StrComp( DateFound$, Left$( TestString$, 4 ) ) = STRING1_LESS_THAN Then
          Exit For
        Else

' If a lot of text follows or precedes the date, discard it.

          If Len( TempString$ ) - RevDate% > STRING_CHOMPER Then
              TempString$ = Trim$( Left$( TempString$, RevDate% + STRING_CHOMPER ) ) & "..."
          End If
          If RevDate% > 40 Then
              TempString$ = "..." & Trim$( Mid$( TempString$, RevDate% - 28 ) )
          End If

' Now look for a word indicating revision.

          For k = 0 To UBound( UpdateClues )
            RevWord% = InStr( TempString$, UpdateClues( k ) )
            If RevWord% <> 0 Then             'a revision word is found
                If RevWord% > 7 Then          'if the word is far enough along in the string, check for "Last" preceding it
                    If Mid$( TempString$, RevWord% - 4, 4 ) = "ast " Then   'if "Last" is found before the revision word,
                        If RevWord% > 10 Then                               'chop off all preceding it
                            TempString$ = Mid$( TempString$, RevWord% - 6 )
                        End If
                      Else
                        TempString$ = Mid$( TempString$, RevWord% - 1 )
                    End If
                End If
                j = UBound( UpdateDate )
                Exit For
            End If
          Next k
          If RevWord% > 0 Then
              TestString$ = DateFound$ & TempString$
            Else         'Date found, but no revision word: Accept it anyway
              TestString$ = "    " & TempString$
              Exit For
          End If
      End If
  End If
Next j

TempString$ = Mid$( TestString$, 5 )
If TempString$ = " " Then
    FindRevisionDate = ""
  Else
    If Left$( TempString$, 1 ) = "'" Then
        TempString$ = Trim$( Mid$( TempString$, 2 ) )
    End If
    FirstChar% = Asc( Left$( TempString$, 1 ) )
    If FirstChar% > 96 And FirstChar% < 123 Then
        FirstChar% = FirstChar% - 32
        Mid( TempString$, 1, 1 ) = Chr$( FirstChar% )
    End If
    FindRevisionDate = Trim$( TempString$ )
End If

End Function

'****************************************************************************************

Function FormatDuration( BeginTime#, EndTime# ) As String

' This function is used when timing macros to (arbitrarily) reduce significant digits
' after the decimal to three.

Const DECIMAL_PLACES As Integer = 3

Dim TempTime#
Dim TimeString$

Dim i As Integer, j As Integer

TempTime#   = Format( EndTime# - BeginTime#, "#.###" )
TimeString$ = Trim$( Str$( TempTime# ) )
i           = InStr( TimeString$, "." )
If i = 0 Then
    TimeString$ = TimeString$ & ".000"
  Else
    j = DECIMAL_PLACES - ( Len( TimeString$ ) - i )
    If j < 3 Then
        TimeString$ = TimeString$ & String$( j, 48 )
    End If
    If i = 1 Then
        TimeString$ = "0" & TimeString$
    End If
End If

FormatDuration = TimeString$

End Function

'****************************************************************************************

Function FormatTimeButton( TimeString$ ) As String

' This little function adds an ampersand to make the decimal point on the elapsed time
' button the hotkey.

Dim p As Integer

p = InStr( TimeString$, "." )
If p < 2 Then
    FormatTimeButton = "&" & TimeString$
  Else
    FormatTimeButton = Left$( TimeString$, p - 1 ) & "&" & Mid$( TimeString$, p )
End If

End Function

'****************************************************************************************

Function GetKeyAssignment( FullMacroName$ )

' To find a keystroke shortcut assigned to a selected macro, this subprogram first looks
' for the file "Custom.Keymap.xml," usually stored in "X:\Documents and Settings\[user
' name]\Application Data\OCLC\Connex\Profiles\MyProfile\". If the file is found, it is
' searched for the macro name, and if that is found, the keystroke shortcut is extracted.
' If no keystroke sequence has been assigned, the subprogram then looks for a user tool
' assignment. This is stored in the "Options.xml" file in the same directory. If the
' macro name is found in this file, the user tool assignation is extracted.

Const CASE_SENSITIVE As Integer = 0   'The value to force a string match test to consider case.

Dim Attributes%
Dim CustomKeymapFile$
Dim FileNum%
Dim KeyString$
Dim KeyStringEnd%
Dim KeyStringStart%
Dim NullChar$                : NullChar$ = Chr$( 0 )
Dim OptionsFile$
Dim Start%                   : Start%    = 1
Dim TempString$
Dim TestChar%
Dim UnicodeMacroName$

Dim i As Integer, p As Integer, q As Integer

' First, get to the keymap file; if not in the expected place, no key assignment can be
' displayed. Prior to Windows 7, the file was stored in the path defined by the
' UserProfile$ variable and "\Application Data\OCLC\Connex\Profiles\MyProfile\Custom.Keymap.xml".

CustomKeymapFile$ = UserProfile$ & "\AppData\Roaming\OCLC\Connex\Profiles\MyProfile\Custom.Keymap.xml"
On Error GoTo Done:
Attributes% = GetAttr( CustomKeymapFile$ )
If Attributes% = 0 Or Attributes% = 32 Then
    On Error GoTo NoFile:
    Call ReadFile ( CustomKeymapFile$ )
    Call StoreWithTerminator( FILE_DATA% )

' If the file is found, search in it for the macro name. This is a Unicode rather than a
' text file, so null characters must be added to the macro name to make it look like
' Unicode in order to match. In this case, the comparison must be by byte, not by
' character.

    For p = 1 To Len( FullMacroName$ )
      UnicodeMacroName$ = UnicodeMacroName$ & Mid$( FullMacroName$, p, 1 ) & NullChar$
    Next p
    For i = 0 To UBound( EndWithLF )
      KeyString$ = EndWithLF( i )
      p = InStr( Start%, KeyString$, UnicodeMacroName$, CASE_SENSITIVE )
      If p <> 0 Then

' If the name is found, step backward in the string to the end of the previous line
' (marked by the line feed character, ASCII 10), and then jump forward to the beginning
' of the keystroke string.

          KeyStringEnd% = p - 18
          q = KeyStringEnd%
          Do
            q = q - 2
            TestChar% = Asc( Mid$( KeyString$, q ) )
          Loop Until TestChar% = 10
          KeyStringStart% = q + 32
          TempString$     = Mid$( KeyString$, KeyStringStart%, KeyStringEnd% - KeyStringStart% - 1 )

' Take out the null characters from the keystroke string.

          Do
            p = InStr( TempString$, NullChar$ )
            If p <> 0 Then
                TempString$ = Left( TempString$, p - 1 ) & Mid$( TempString$, p + 1 )
            End If
          Loop Until p = 0

' Microsoft says to developers: "Don't use the following characters for shortcut keys: @
' ? $ {} [] \ ~ | ^ ' < >. These characters require different key combinations across
' languages or are locale specific." So the following substitutions may not work on every
' computer.

          p = InStr( TempString$, "Oem" )
          If p <> 0 Then
              Select Case Mid$( TempString$, p + 3 )
                Case "1"
                  TempString$ = Left$( TempString$, p - 1 ) & "Semicolon"
                Case "5"
                  TempString$ = Left$( TempString$, p - 1 ) & "Backslash"
                Case "6"
                  TempString$ = Left$( TempString$, p - 1 ) & "CloseBrackets"
                Case "7"
                  TempString$ = Left$( TempString$, p - 1 ) & "Quotes"
              End Select
          End If
          TempString$ = "Shortcut keystrokes: " & TempString$
          GoTo Done:
      End If
    Next i
End If

' If the macro has not been assigned to a keystroke, check for assignation to a user
' tool.

'OptionsFile$ = UserProfile$ & "\Application Data\OCLC\Connex\Profiles\MyProfile\Options.xml"
OptionsFile$ = UserProfile$ & "\AppData\Roaming\OCLC\Connex\Profiles\MyProfile\Options.xml"
On Error GoTo NoFile:
Attributes%  = GetAttr( OptionsFile$ )
If Attributes% = 0 Or Attributes% = 32 Then
    Call ReadFile (OptionsFile$)
    On Error GoTo NoFile:
    Call StoreWithTerminator( FILE_DATA% )
    For i = 0 To UBound( EndWithLF )
      KeyString$ = EndWithLF( i )
      Do
        p = InStr( Start%, KeyString$, FullMacroName$ )
        If p <> 0 Then

' The macro name appears in this file twice, once as the value for item key "Tool X" and
' also as the value for item key "UserToolTipX". Thus, when the name is found, check
' which item key it is for.

            If Mid$( KeyString$, p - 21, 5 ) = "Tool " Then
                TempString$ = Mid$( KeyString$, p - 21, 7 )
                If Right$( TempString$, 1 ) = DoubleQuote$ Then
                    TempString$ = Left$( TempString$, Len( TempString$ ) - 1 )
                End If
                TempString$ = "User tool: " & TempString$
                GoTo Done:
              Else
                Start% = p + 4
            End If
        End If
        i = i + 1
      Loop Until p = 0
    Next i
End If

Done:

GetKeyAssignment = TempString$

NoFile:

End Function

'****************************************************************************************

Function GetSectorData( SectorID&, WhichDataArray% ) As String

' Given a sector ID and the appropriate array (that containing file data or that
' containing Ministream data), this function retrieves the data in that sector. Since the
' first character in a string is at position 1, but the first element of an array is
' numbered 0, an offset of 1 has to be added.

Dim StartPos&
Dim WhichElement%

If WhichDataArray% = MAIN_C Then
    StartPos&     = ( SectorID& * SECTOR_SIZE ) + SECTOR_SIZE + STRING_OFFSET
    WhichElement% = Int( StartPos& / MAX_STRING_LENGTH )
    StartPos&     = StartPos& - ( MAX_STRING_LENGTH * CLng( WhichElement% ) )
    GetSectorData = Mid$( FileSectors( WhichElement% ), StartPos&, SECTOR_SIZE )
  Else
    StartPos&     = ( SectorID& * MINI_SECTOR_SIZE ) + STRING_OFFSET
    WhichElement% = Int( StartPos& / MAX_STRING_LENGTH )
    StartPos&     = StartPos& - ( MAX_STRING_LENGTH * CLng( WhichElement% ) )
    GetSectorData = Mid$( MinistreamSectors( WhichElement% ), StartPos&, MINI_SECTOR_SIZE )
End If

End Function

'****************************************************************************************

Function HexVal( InBytes$ ) As Long

' This function converts the string of bytes to a hex number and then to decimal (thanks
' to Joel Hahn for insight into this function). It perhaps is not strictly necessary, but
' the raw bytes must be manipulated anyway, as they are in little-endian order, and for
' this non-programmer, decimal is much easier to read than hex.

Dim ASCIIChar%
Dim Byte$
Dim HexString$

Dim i As Integer

For i = 1 To Len( InBytes$ )
  ASCIIChar% = Asc( Mid$( InBytes$, i, 1 ) )
  Byte$      = Hex$( ASCIIChar% )
  If Len(Byte$) = 1 Then
      Byte$ = "0" & Byte$
  End If
  HexString$ = Byte$ & HexString$
Next i

HexString$ = "&H" & Trim$( UCase$( HexString$ ) )
HexVal     = Val( HexString$ )

End Function

'****************************************************************************************

Function MatchCalls( MacroLine$, LineCount& ) As String

' This routine checks for matching Sub...End Sub and Function...End Function statements
' (including those called with the "Private" or "Static" keywords) as a clue to macro
' corruption.

Const LEN_TEST_STRING As Integer = 12  'Arbitrary limit to how much of the line to read looking for
                                       ' "Function" and "Sub" words.

Dim CurrentLine$
Dim TestString As String*LEN_TEST_STRING
Dim Warning$

TestString   = LCase$( Trim$( MacroLine$ ) )
CurrentLine$ = Trim$( Str$( LineCount& ) )

' If a sub is invoked, see if there is a previous "Sub" still open (the first character
' in "MatchCache$" should be a space, indicating a previous subprogram or function has
' been closed). If no "Sub" is open, reset the first character in "MatchCache$" to show a
' "Sub" was found; otherwise build the warning that an "End" is missing.

If Left$( TestString, 4 ) = "sub " Or TestString = "private sub " Or Left$( TestString, 11 ) = "static sub " Then
    If Left$( MatchCache$, 1 ) = "S" Then
        Warning$ = "Closing " & DoubleQuote$ & "End Sub" & DoubleQuote$ & " lacking."
      ElseIf Left$( MatchCache$, 1 ) = "F" Then
        Warning$ = "Closing " & DoubleQuote$ & "End Function" & DoubleQuote$ & " lacking."
      Else
        MatchCache$ = "S" & CurrentLine$
    End If

' Similarly for a function:

  ElseIf Left$( TestString, 9 ) = "function " Or TestString = "private func" Or TestString = "static funct" Then
    If Left$( MatchCache$, 1 ) = "S" Then
        Warning$ = "Closing " & DoubleQuote$ & "End Sub" & DoubleQuote$ & " lacking."
      ElseIf Left$( MatchCache$, 1 ) = "F" Then
        Warning$ = "Closing " & DoubleQuote$ & "End Function" & DoubleQuote$ & " lacking."
      Else
        MatchCache$ = "F" & CurrentLine$
    End If

' If a sub is ended, see if there is an open sub (the first character in "MatchCache$"
' should be "S"); if so, reset the first character in "MatchCache$" to a space. If not,
' construct the warning, including the line number of the "End".

  ElseIf Left$( TestString, 7 ) = "end sub" Then
    If Left$( MatchCache$, 1 ) = "S" Then
        MatchCache$ = " "
      Else
        Warning$ = "Unexpected " & DoubleQuote$ & "End Sub" & DoubleQuote$ & " found on line " & CurrentLine$ & "."
    End If

' Similarly for a function:

  ElseIf TestString = "end function" Then
    If Left$( MatchCache$, 1 ) = "F" Then
        MatchCache$ = " "
      Else
        Warning$ = "Unexpected " & DoubleQuote$ & "End Function" & DoubleQuote$ & " found on line " & CurrentLine$ & "."
    End If
End If

MatchCalls = Warning$

End Function

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, SuppVal& )

' This function controls the initial setup and subsequent behavior of the main dialog
' box. The box remains open until the "Close" button is clicked, so several lists or
' macros can be saved.

Const DISABLED       As Integer = 0   'The value to make a dialog box control disabled.
Const ENABLED        As Integer = 1   'The value to make a dialog box control enabled.
Const INVISIBLE      As Integer = 0   'The value to make a dialog box control invisible.
Const VISIBLE        As Integer = 1   'The value to make a dialog box control visible.

Dim Header$
Dim InfoBoxLegend$
Dim MacroInfo$
Dim MaxPreview$
Dim SelectedFile%
Dim SelectedMbkFile$
Dim SrcName$
Dim TotalTime$

Dim ListChoosing( 1 ) As String
ListChoosing( 0 ) = "Macros are listed in this box. Click on a"
ListChoosing( 1 ) = "macro name for more information."

Select Case Action%

' For the initial setup, hide most of the labels and data; they'll reappear when a macro
' book has been chosen and there is a list of macros to display. Show the warning about a
' possible delay if a macro is large. The beginning save option is for the macro book
' list.

  Case INITIALIZE
    DlgVisible          "Cancel",           INVISIBLE
    DlgVisible          "Clipboard",        INVISIBLE
    DlgVisible          "Description",      INVISIBLE
    DlgValue            "ListOfMacroBooks", 0
    DlgFocus            "ListOfMacroBooks"
    DlgVisible          "FileInfo",         INVISIBLE
    DlgVisible          "FileKBs",          INVISIBLE
    DlgListBoxArray     "ListOfMacros",     ListChoosing()
    DlgVisible          "MacroCount",       INVISIBLE
    DlgVisible          "MacroLines",       INVISIBLE
    DlgVisible          "MacroSize",        INVISIBLE
    DlgVisible          "NameDiffers",      INVISIBLE
    DlgVisible          "NameDiffersBox",   INVISIBLE
    DlgVisible          "OutlineDesc",      INVISIBLE
    DlgVisible          "OutlineInfo",      INVISIBLE
    DlgVisible          "PreviewButton",    INVISIBLE
    DlgVisible          "PreviewText",      INVISIBLE
    DlgVisible          "RevDate",          INVISIBLE
    DlgEnable           "SaveList",         DISABLED
    DlgEnable           "SaveMacro",        DISABLED
    DlgVisible          "SelectBooks",      VISIBLE
    DlgVisible          "SelectMacro",      INVISIBLE
    DlgVisible          "Shortcut",         INVISIBLE
    DlgVisible          "TimeButton",       INVISIBLE

  Case CONTROL_CHANGE
    Select Case Id$

' When a macro book is selected, make the list of its macros, but stop there unless the
' macro book contains a single macro--in which case continue with getting its
' information. Otherwise, wait until a macro is selected, because analysis of a large
' macro (although there is no way to know how large a macro is until it's analyzed) added
' to analysis of a large macro book may cause excessive delay in displaying anything.
' Time the exection of the macro, just for fun. Show or hide dialog box controls as
' appropriate.

      Case "ListOfMacroBooks"
        SelectedFile% = DlgValue( "ListOfMacroBooks" )
        If SelectedFile% > 0 Then
            SelectedMbkFile$ = MacroBooks( SelectedFile% )
            BeginMML#        = Timer
            Call GetFileInfo( SelectedMbkFile$ )
            Call MakeMacroList( SelectedMbkFile$ )
            FinishMML#       = Timer
            TimeMML$         = FormatDuration( BeginMML#, FinishMML# )
            TotalTime$       = FormatTimeButton( TimeMML$ )
            If InvalidFileLength = TRUE Then
                MsgBox "This is a corrupt file! Its length is invalid. Some or all of its macros may not work, even though they display correctly.", WARNING_MESSAGE, WaltsMacros$
            End If
            DlgListBoxArray     "ListOfMacros",     MacroListNames()
            DlgValue            "ListOfMacros",     0
            DlgText             "FileInfo",         FileInfo$
            DlgVisible          "FileInfo",         VISIBLE
            DlgText             "FileKBs",          Space$( 12 - Len( FileSizeKBStr$ ) ) & FileSizeKBStr$ & " KB"
            DlgVisible          "FileKBs",          VISIBLE
            DlgText             "MacroCount",       SummaryMacroCount$
            DlgVisible          "MacroCount",       VISIBLE
            DlgText             "TimeButton",       TotalTime$
            DlgVisible          "TimeButton",       VISIBLE
            ReDim MasterMacroArray( TotalMacroCount%, 0 )

' Only one macro in macro book: get its information immediately. The default save option
' is to save the macro text.

            If TotalMacroCount% = 0 Then
                SelectedMacroIndex% = DlgValue( "ListOfMacros" )
                Call AssembleMacroInfo( SelectedMacroIndex% )
                MacroInfo$          = MasterMacroArray( SelectedMacroIndex%, 0 )
                InfoBoxLegend$      = "Information about " & DoubleQuote$ & GetField$( MacroInfo$, MACRO_INFO_NAME, TabChar$ ) & DoubleQuote$
                DlgVisible          "Clipboard",        INVISIBLE
                MacroDesc$          = GetField$( MacroInfo$, MACRO_INFO_DESC, TabChar$ )
                DlgText             "Description",      MacroDesc$
                DlgVisible          "Description",      VISIBLE
                DlgText             "FileInfo",         FileInfo$
                DlgFocus            "ListOfMacros"
                DlgText             "MacroLines",       "Number of lines in macro: " & GetField$( MacroInfo$, MACRO_INFO_LINES, TabChar$ )
                DlgVisible          "MacroLines",       VISIBLE
                DlgText             "MacroSize",        "Size of macro source/binary: " & GetField$( MacroInfo$, MACRO_INFO_SRC, TabChar$ ) & "/" & GetField$( MacroInfo$, MACRO_INFO_BIN, TabChar$ )
                DlgVisible          "MacroSize",        VISIBLE
                If GetField$( MacroInfo$, MACRO_INFO_XDESC, TabChar$ ) = "0" Then
                    DlgText             "OutlineDesc",      "Description:"
                  Else
                    DlgText             "OutlineDesc",      "Description (differs in source):"
                End If
                DlgVisible          "OutlineDesc",      VISIBLE
                SrcName$            = GetField$( MacroInfo$, MACRO_INFO_XNAME, TabChar$ )
                If SrcName$ = "" Then
                    DlgText             "OutlineInfo",      InfoBoxLegend$ & ": "
                    DlgVisible          "OutlineInfo",      VISIBLE
                    DlgVisible          "NameDiffers",      INVISIBLE
                    DlgVisible          "NameDiffersBox",   INVISIBLE
                  Else
                    DlgText             "OutlineInfo",      InfoBoxLegend$ & "*: "
                    DlgText             "NameDiffers",      " *Name in source: " & DoubleQuote$ & SrcName$ & DoubleQuote$
                    DlgVisible          "NameDiffers",      VISIBLE
                    DlgVisible          "NameDiffersBox",   VISIBLE
                End If
                DlgVisible          "PreviewButton",    VISIBLE
                DlgVisible          "PreviewText",      VISIBLE
                DlgText             "RevDate",          GetField$( MacroInfo$, MACRO_INFO_REV, TabChar$ )
                DlgVisible          "RevDate",          VISIBLE
                DlgEnable           "SaveList",         ENABLED
                DlgEnable           "SaveMacro",        ENABLED
                DlgVisible          "SelectMacro",      INVISIBLE
                DlgText             "Shortcut",         GetField$( MacroInfo$, MACRO_INFO_KEY, TabChar$ )
                DlgVisible          "Shortcut",         VISIBLE
                If GetField$( MacroInfo$, MACRO_INFO_MATCH, TabChar$ ) <> "" Then
                    MsgBox MatchWarning$, WARNING_MESSAGE, WaltsMacros$
                End If

' More than one macro: focus on the list of macros for selection of one of them to
' process. Set the default save option to be to save the whole list.

              Else
                SelectedMacroName$ = ""
                DlgVisible          "Clipboard",        VISIBLE
                DlgVisible          "Description",      INVISIBLE
                DlgVisible          "MacroLines",       INVISIBLE
                DlgVisible          "MacroSize",        INVISIBLE
                DlgVisible          "NameDiffers",      INVISIBLE
                DlgVisible          "NameDiffersBox",   INVISIBLE
                DlgVisible          "OutlineDesc",      INVISIBLE
                DlgVisible          "OutlineInfo",      INVISIBLE
                DlgVisible          "PreviewButton",    INVISIBLE
                DlgVisible          "PreviewText",      INVISIBLE
                DlgVisible          "RevDate",          INVISIBLE
                DlgEnable           "SaveList",         ENABLED
                DlgEnable           "SaveMacro",        DISABLED
                DlgVisible          "SelectBooks",      INVISIBLE
                DlgVisible          "SelectMacro",      VISIBLE
                DlgVisible          "Shortcut",         INVISIBLE
                TimeGMI$           = "NA"
            End If

' No macro selected: send the focus of the dialog box back to the macro book list. Set
' the default save option to be to save the directory list.

          Else
            DlgListBoxArray     "ListOfMacros",     ListChoosing$()
            DlgFocus            "ListOfMacroBooks"
            DlgVisible          "Clipboard",        INVISIBLE
            DlgVisible          "Description",      INVISIBLE
            DlgVisible          "FileInfo",         INVISIBLE
            DlgVisible          "FileKBs",          INVISIBLE
            DlgVisible          "MacroCount",       INVISIBLE
            DlgVisible          "MacroLines",       INVISIBLE
            DlgVisible          "MacroSize",        INVISIBLE
            DlgVisible          "NameDiffers",      INVISIBLE
            DlgVisible          "NameDiffersBox",   INVISIBLE
            DlgVisible          "OutlineDesc",      INVISIBLE
            DlgVisible          "OutlineInfo",      INVISIBLE
            DlgVisible          "PreviewButton",    INVISIBLE
            DlgVisible          "PreviewText",      INVISIBLE
            DlgVisible          "RevDate",          INVISIBLE
            DlgEnable           "SaveList",         ENABLED
            DlgEnable           "SaveMacro",        DISABLED
            DlgVisible          "SelectBooks",      VISIBLE
            DlgVisible          "SelectMacro",      INVISIBLE
            DlgVisible          "Shortcut",         INVISIBLE
            DlgVisible          "TimeButton",       INVISIBLE
        End If

' A macro is selected.

      Case "ListOfMacros"
        If DlgValue( "ListOfMacroBooks" ) = 0 Then   'No macrobook is selected: do nothing
            DlgFocus            "ListOfMacroBooks"
          Else
            SelectedMacroIndex% = DlgValue( "ListOfMacros" )
            If MasterMacroArray( SelectedMacroIndex%, 0 ) = "" Then
                Call AssembleMacroInfo( SelectedMacroIndex% )
            End If

' Whenever a macro is selected, show its information.

            MacroInfo$     = MasterMacroArray( SelectedMacroIndex%, 0 )
            InfoBoxLegend$ = "Information about " & DoubleQuote$ & GetField$( MacroInfo$, MACRO_INFO_NAME, TabChar$ ) & DoubleQuote$
            DlgVisible          "Clipboard",        INVISIBLE
            DlgVisible          "Description",      VISIBLE
            MacroDesc$     = GetField$( MacroInfo$, MACRO_INFO_DESC, TabChar$ )
            DlgText             "Description",      MacroDesc$
            DlgText             "FileInfo",         FileInfo$
            DlgFocus            "ListOfMacros"
            DlgText             "MacroLines",       "Number of lines in macro: " & GetField$( MacroInfo$, MACRO_INFO_LINES, TabChar$ )
            DlgVisible          "MacroLines",       VISIBLE
            DlgText             "MacroSize",        "Size of macro source/binary: " & GetField$( MacroInfo$, MACRO_INFO_SRC, TabChar$ ) & "/" & GetField$( MacroInfo$, MACRO_INFO_BIN, TabChar$ )
            DlgVisible          "MacroSize",        VISIBLE
            If GetField$( MacroInfo$, MACRO_INFO_XDESC, TabChar$ ) = "0" Then
                DlgText             "OutlineDesc",      "Description:"
              Else
                DlgText             "OutlineDesc",      "Description (differs in source):"
            End If
            DlgVisible          "OutlineDesc",      VISIBLE
            SrcName$       = GetField$( MacroInfo$, MACRO_INFO_XNAME, TabChar$ )
            If SrcName$ = "" Then
                DlgText             "OutlineInfo",      InfoBoxLegend$ & ": "
                DlgVisible          "NameDiffers",      INVISIBLE
                DlgVisible          "NameDiffersBox",   INVISIBLE
              Else
                DlgText             "OutlineInfo",      InfoBoxLegend$ & "*: "
                DlgText             "NameDiffers",      " *Name in source: " & DoubleQuote$ & SrcName$ & DoubleQuote$
                DlgVisible          "NameDiffers",      VISIBLE
                DlgVisible          "NameDiffersBox",   VISIBLE
            End If
            DlgVisible          "OutlineInfo",      VISIBLE
            DlgVisible          "PreviewButton",    VISIBLE
            DlgVisible          "PreviewText",      VISIBLE
            DlgText             "RevDate",          GetField$( MacroInfo$, MACRO_INFO_REV, TabChar$ )
            DlgVisible          "RevDate",          VISIBLE
            DlgEnable           "SaveList",         ENABLED
            DlgEnable           "SaveMacro",        ENABLED
            DlgVisible          "SelectMacro",      INVISIBLE
            DlgText             "Shortcut",         GetField$( MacroInfo$, MACRO_INFO_KEY, TabChar$ )
            DlgVisible          "Shortcut",         VISIBLE
            If GetField$( MacroInfo$, MACRO_INFO_MATCH, TabChar$ ) <> "" Then
                MsgBox MatchWarning$, WARNING_MESSAGE, WaltsMacros$
            End If
        End If

' If the radio buttons are clicked to change what to save, change the string supplied to
' the text box and set the focus to the "Save" button, assuming an immediate save is
' desired.

      Case "SaveList"
        Call WriteFile( SAVE_LIST )
        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "OK"

      Case "SaveMacro"
        Call WriteFile( SAVE_MACRO )
        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "OK"

' If the "Preview" button is clicked, display the window showing the first bit of the
' macro.

      Case "PreviewButton"
        SelectedMacroIndex% = DlgValue( "ListOfMacros" )
        MacroInfo$          = MasterMacroArray( SelectedMacroIndex%, 0 )
        MaxPreview$         = GetField$( MacroInfo$, MACRO_INFO_PREVIEW, TabChar$ )
        Header$             = LineCountReport$ & " " & FullMacroName$

        Begin Dialog Dialog4Definition 400, 262, WaltsMacros$
          CancelButton  168, 238,  64,  16
          Text            8,   8, 384,   8, Header$
          GroupBox        8,  18, 384, 212, ""
          Text           16,  26, 368, 200, MaxPreview$
        End Dialog

        Dim Dialog4 As Dialog4Definition
        On Error Resume Next
        Dialog Dialog4

        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "OK"

' When the button showing the elapsed time is clicked, call the subprogram to display it.
' The text of the button doesn't change even when the time to assemble a macro is added
' to the dialog box.

      Case "TimeButton"
        Call ShowTimes
        Dialog1ControlFunction = KEEP_DLG_OPEN
        DlgFocus            "OK"

    End Select

End Select

End Function

'****************************************************************************************

Function Dialog3ControlFunction( Id$, Action%, SuppVal& )

Select Case Action%

  Case INITIALIZE
    DlgValue            "ComboBox",         0

  Case CONTROL_CHANGE
    If Id$ = "Clear" Then
        DlgText             "ComboBox",         ""
        Dialog3ControlFunction = KEEP_DLG_OPEN
    End If

End Select

End Function
'2610116251
'
'Macro name: MacroBookInspector
'Macro book: C:\Program Files (x86)\OCLC\Connexion\Program\Macros\MacroTools.mbk
'Saved: 6/28/2017 11:37:30 AM using "MacroBookInspector" macro by Walter F. Nickeson.
