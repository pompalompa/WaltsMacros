'MacroName:CursorJump.2015.01
'MacroDescription:Moves the cursor to the specified position in the current field.
'
' This macro was written by Walter F. Nickeson,
' University of Rochester, Rochester, NY
' wnickeson@library.rochester.edu
'
' Thanks to Harvey Hahn for some help with dialog boxes.
'
' Last updated: 1 May 2015.
' Check for the latest versions of this and my other macros at
' https://github.com/wnickeson/WaltsMacros
' Please e-mail me with bug reports or to suggest improvements.
'
' This macro works for me with Connexion client 2.63 and 64-bit Windows 7 Enterprise &
' 64-bit Windows 10 Pro, but no guarantees are promised or implied.
'
'****************************************************************************************
' How it works: This macro was written to help find illegal characters (i.e., characters
' that won't validate) in a field when the "Validation Results" window gives the
' positions of those characters. Run the macro with the cursor in the field in which
' illegal characters have been identified. The macro displays a dialog box in which to
' enter the position in the subfield to which to jump. If there is more than one
' subfield, select the subfield, and if appropriate its occurrence, from the drop-down
' list. The macro moves the cursor to that position and leaves the character there
' selected for easy editing (i.e., simply type to replace it). Some characters may prove
' to be unfindable by this macro. Joel Hahn's "CvtDiacritics" macro (available at
' <http://www.hahnlibrary.net/libraries/oml/macros/CvtDiacritics.txt> will probably be
' able to manage those by changing them to something more appropriate (and valid).
'****************************************************************************************

Option Explicit

Type SubfieldStructure
  Code       As String*1
  Length     As Integer
  Occurrence As Integer
  Position   As Integer
End Type

Declare Function Dialog1ControlFunction( Id$, Action%, Suppvalue& )

Global SelectionIndex%
Global SubfieldCount%
Global WaltsMacros$

Global SubfieldCodes() As String
Global Subfields()     As SubfieldStructure

'****************************************************************************************

Sub Main

Const CANCEL           As Integer = 102 'The value returned by the dialog box when the "Cancel" button is clicked.
Const CRITICAL_MESSAGE As Integer = 16  'The value to display a "Critical message" (which includes the red button with
                                        ' a big "X") in a message box; used to report the macro quitting.

Dim CS As Object
Set CS = CreateObject("Connex.Client")

Dim CurrentField$
Dim Delimiter$               : Delimiter$  = Chr$( 223 )
Dim FieldData$
Dim FillChar$                : FillChar$   = Chr$( 252 )
Dim Incumbent$
Dim Occurrence%
Dim Row%
Dim Start%
Dim SubfieldCode$
Dim SubfieldInfo As SubfieldStructure
Dim SubfieldLength%
Dim Tag$
Dim TagDisplay$
Dim TempOccurrence%
Dim TempSubInfo As SubfieldStructure
Dim TestTag$
Dim UBSubfields%
Dim UniChar$
Dim WindowType%

Dim BeginsWithA              : BeginsWithA = FALSE
Dim FoundField

Dim i As Integer, j As Integer, p As Integer, q As Integer

SubfieldCount% = -1
WaltsMacros$   = "[Walt's macros] Extras1:CursorJump"

' First, make sure that the type of window is bibliographic or authority; if it is any
' other type, exit the macro.

WindowType% = CS.ItemType
Select Case WindowType%
  Case -1, 5 To 13, 15 To 16, 21 To 25, 36
    MsgBox "This macro works only in bibliographic and authority records!", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End Select

' Then retrieve the field, in Unicode so as to be able to include all characters, not
' just MARC. Make sure the field is a variable data field (010-999). Strip it of tag and
' indicators.

Row% = CS.CursorRow
If CS.GetFieldLineUnicode( Row%, CurrentField$ ) Then
    If Left$( CurrentField$, 2 ) = "00" Or Left$( CurrentField$, 1 ) = "L" Then
        MsgBox "Sorry, this macro only works in fields 010 and higher.", CRITICAL_MESSAGE, WaltsMacros$
        Exit Sub
      ElseIf Len( Trim$( CurrentField$ ) ) = 7 And Mid$( CurrentField$, 6, 1 ) = Delimiter$ Then
        MsgBox "This field contains no content.", CRITICAL_MESSAGE, WaltsMacros$
        Exit Sub
    End If
    Tag$ = Left$( CurrentField, 3 )
    If Left$( Tag$, 1 ) = FillChar$ Then Tag$ = "unlabeled"
    i = Row% - 1

' Check the tag of the neighbors of the selected field, in order to display the
' occurrence number if more than one field has the same tag. Start with the previous
' field(s) in the array. Go back until the first field with that tag is found; that
' determines the place in the group.

    Occurrence% = 0
    Do
      FoundField = CS.GetFieldLineUnicode( i, FieldData$ )
      If FoundField Then
          TestTag$ = Left$( FieldData$, 3 )
          If TestTag$ = Tag$ Then
              Occurrence% = Occurrence% + 1
              i = i - 1
            Else
              If Occurrence% > 0 Then
                  Occurrence% = Occurrence% + 1
              End If
              Exit Do
          End If
      End If
    Loop Until FoundField = FALSE

' If no previous occurrences of the field are found, then this field is the first, and
' the only other field to check is the next one.

    If Occurrence% = 0 Then
        FoundField = CS.GetFieldLine( Row% + 1, FieldData$ )
        If FoundField Then
            TestTag$ = Left$( FieldData$, 3 )
            If TestTag$ = Tag$ Then
                Occurrence% = 1
            End If
        End If
    End If

' Replace each Numeric Character Reference, which is eight characters in length, with a
' fill character (except the delimiter). This substitution will unfortunately fail for
' combining and other characters (Unicode characters in the "Mark, Nonspacing" category),
' which should be omitted entirely to keep positions accurate; but to take into account
' all 1400+ of these special characters is beyond the scope of this simple macro.

    Do
      p = InStr( " " & CurrentField$, "&#x" )
      If p <> 0 Then
          UniChar$ = Mid$( CurrentField$, p - 1, 8 )
          If UniChar$ = "&#x01C2;" Then
              CurrentField$ = Left$( CurrentField$, p - 2 ) & Delimiter$ & Mid$( CurrentField$, p + 7 )
            ElseIf Right$( UniChar$, 1 ) = ";" Then
              CurrentField$ = Left$( CurrentField$, p - 2 ) & FillChar$ & Mid$( CurrentField$, p + 7 )
          End If
      End If
    Loop Until p = 0
    CurrentField$ = Trim$( Mid$( CurrentField$, 6 ) )
  Else
    MsgBox "Sorry, the macro failed.", CRITICAL_MESSAGE, WaltsMacros$
    Exit Sub
End If

' Since "$a" does not display, it must be added to the beginning of the string if it is
' indeed the first subfield, just to make sure it's counted.

If Left$( CurrentField$, 1 ) <> Delimiter$ Then
    CurrentField$ = Delimiter$ & "a " & CurrentField$
    BeginsWithA   = TRUE
End If

' Everything is now in place to find all the subfields in the field. For each subfield,
' keep track of its code, its position in the field, and its length.

Start% = 1
Do
  p = InStr( Start%, CurrentField$, Delimiter$ )
  If p <> 0 Then
      SubfieldCode$  = Mid$( CurrentField$, p + 1, 1 )
      SubfieldCount% = SubfieldCount% + 1
      q = InStr( p + 1, CurrentField$, Delimiter$ )
      If q <> 0 Then
          SubfieldLength% = q - p - 4
        Else
          SubfieldLength% = Len( CurrentField$ ) - p - 2
      End If
      SubfieldInfo.Code       = SubfieldCode$
      SubfieldInfo.Length     = SubfieldLength%
      SubfieldInfo.Occurrence = 0
      SubfieldInfo.Position   = p + 3

' Place the record containing information for each subfield in an array, inserting it
' in alphabetical order by subfield code (this puts subfields with numeric codes first,
' but that will get fixed later). As each subfield is added, adjust the sequence number,
' if necessary; the default number is zero. It gets adjusted as subsequent subfields
' sharing the same code are added.

      ReDim Preserve Subfields( SubfieldCount% )
      For i = 0 To UBound( Subfields )

' The first subfield found simply gets inserted into the first element of the array.

        If SubfieldCount% = 0 Then
            Subfields( SubfieldCount% ) = SubfieldInfo
            Exit For
          Else
            Incumbent$ = Subfields( i ).Code
            Select Case SubfieldInfo.Code

' If the subfield code of the next subfield is less than that of the element of the array
' it is being compared to, insert it there, moving all subsequent elements up one.

              Case Is < Incumbent$
                For j = UBound( Subfields ) To i + 1 Step -1
                  Subfields( j ) = Subfields( j - 1 )
                Next j
                Subfields( i ) = SubfieldInfo

' Compare the newly inserted subfield with the one preceding it in the array. If they
' have the same subfield code, their occurrence numbers need to be adjusted. If the
' preceding element had a number of zero, it is changed to 1. Whatever the value it had,
' the newly inserted subfield has an occurrence number incremented by 1.

                If i > 0 Then
                    If Subfields( i ).Code = Subfields( i - 1 ).Code Then
                        TempOccurrence% = Subfields( i - 1 ).Occurrence
                        If TempOccurrence% = 0 Then
                            TempOccurrence%               = 1
                            Subfields( i - 1 ).Occurrence = TempOccurrence%
                        End If
                        If Subfields( i - 1 ).Occurrence > 0 Then
                            Subfields( i ).Occurrence     = TempOccurrence% + 1
                        End If
                    End If
                End If
                Exit For

' If the next subfield has a code the same as or greater than that of the element it is
' being compared to, then insert it into the array immediately, also moving any
' subsequent subfields up one element; thus, subfields with the same code are added in
' the order in which they appear in the field. Adjust the occurrence number of it and its
' preceding element as described above.

              Case Is >= Incumbent$
                If i = UBound( Subfields ) - 1 Then
                    Subfields( i + 1 ) = SubfieldInfo
                    If Subfields( i + 1 ).Code = Subfields( i ).Code Then
                        TempOccurrence% = Subfields( i ).Occurrence
                        If TempOccurrence% = 0 Then
                            TempOccurrence%               = 1
                            Subfields( i ).Occurrence     = TempOccurrence%
                        End If
                        If Subfields( i ).Occurrence > 0 Then
                            Subfields( i + 1 ).Occurrence = TempOccurrence% + 1
                        End If
                    End If
                    Exit For
                End If
            End Select
        End If
      Next i
      Start% = p + 3
  End If

Loop Until p = 0

' Now move any numeric subfields to the end of the array. The reason for this is that it
' is more likely an invalid character will be in an alphabetic subfield than in a numeric
' subfield, so the alphabetic subfields should be presented first.

UBSubfields% = UBound( Subfields )
Do
  SubfieldCode$ = Subfields( 0 ).Code
  If SubfieldCode$ Like "[!a-z]" Then
      TempSubInfo               = Subfields( 0 )
      For i = 0 To UBSubfields% - 1
        Subfields( i ) = Subfields( i + 1 )
      Next i
      Subfields( UBSubfields% ) = TempSubInfo
  End If
Loop Until SubfieldCode$ Like "[a-z]"

' Fill the array for display of the subfield codes in the dialog box. If the occurrence
' number assigned earlier is not zero, add it to the subfield code within brackets.

ReDim SubfieldCodes( UBSubfields% )
For i = 0 To UBSubfields%
  If Subfields( i ).Occurrence = 0 Then
      SubfieldCodes( i ) = Subfields( i ).Code
    Else
      SubfieldCodes( i ) = Subfields( i ).Code & "  [" & CStr( Subfields( i ).Occurrence ) & "]"
  End If
Next i

' For the display of the field the cursor is in, add the occurrence number of the field
' preceded by a forward slash.

If Occurrence% > 0 Then
    TagDisplay$ = Tag$ & "/" & CStr( Occurrence% )
  Else
    TagDisplay$ = Tag$
End If
TagDisplay$ = "[Field " & TagDisplay$ & "]"

' Then run the dialog box to display the subfields for selection and offer a text box in
' which to enter a position. If there is only one subfield in the field, then the control
' is disabled, as there is nothing to select.

Begin Dialog Dialog1Definition  128, 84, WaltsMacros$, .Dialog1ControlFunction
  DropListBox    42,  20,  44,  80, SubfieldCodes(), .SubfieldList
  TextBox        42,  38,  44,  12,                  .Position
  ButtonGroup .Jump
   PushButton     8,  60,  52,  14, "&Go",           .Go
  CancelButton   68,  60,  52,  14
  Text            8,   6,  68,   8, "Move cursor to..."
  Text           80,   6,  44,   8, TagDisplay$
  Text            8,  22,  28,   8, "Subfield:"
  Text            8,  40,  28,   8, "Position:"
End Dialog

Dim Dialog1 as Dialog1Definition
On Error Resume Next
Dialog Dialog1
If Err = CANCEL Then Exit Sub

' Send the cursor to the indicated position.

If BeginsWithA = TRUE Then
    CS.CursorColumn = Subfields( SelectionIndex% ).Position + Val( Dialog1.Position ) + 1
  Else
    CS.CursorColumn = Subfields( SelectionIndex% ).Position + Val( Dialog1.Position ) + 4
End If

' Finish by selecting the character at the chosen position so it can be readily replaced.

SendKeys "+{RIGHT}"

End Sub

'****************************************************************************************

Function Dialog1ControlFunction( Id$, Action%, Suppvalue& )

' This function controls the appearance of the dialog box when it opens.

Const CONTROL_CHANGE  As Integer = 2   'The value of the dialog box function parameter "Action%" when a control changes.
Const DISABLED        As Integer = 0   'The value to make a dialog box control disabled.
Const ENABLED         As Integer = 1   'The value to make a dialog box control enabled.
Const INITIALIZE      As Integer = 1   'The value of the dialog box function parameter "Action%" when the dialog box opens.
Const KEEP_DLG_OPEN   As Integer = -1  'The value of the dialog box function to keep a dialog box open.
Const WARNING_MESSAGE As Integer = 48  'The value to display the "Warning message" icon in a message box.

Dim SubfieldLength%
Dim UserInput$
Dim i As Integer

Select Case Action%

  Case INITIALIZE

' If there is only one subfield in the current field, then disable the drop-list box, as
' there is nothing to select. In that case, give the text box, for position entry, the
' focus for immediate entry.

    If SubfieldCount% = 0 Then
        DlgEnable "SubfieldList",   DISABLED
        DlgFocus  "Position"
      Else
        DlgEnable "SubfieldList",   ENABLED
    End If

  Case CONTROL_CHANGE

' When the "Go" button is clicked, check the input for validity.

    If Id$ = "Go" Then
        SelectionIndex% = DlgValue( "SubfieldList" )
        SubfieldLength% = Subfields( SelectionIndex% ).Length
        UserInput$      = Trim$( DlgText( "Position" ) )
        If UserInput$ = "" Then
            MsgBox "Please enter a position to jump to!", WARNING_MESSAGE, WaltsMacros$
            Dialog1ControlFunction = KEEP_DLG_OPEN
          ElseIf UserInput$ = "0" Then
            MsgBox "The first character is in position 1. Please enter a number larger than zero!", WARNING_MESSAGE, WaltsMacros$
            Dialog1ControlFunction = KEEP_DLG_OPEN
        End If
        If Val( UserInput$ ) > SubfieldLength% Then
            MsgBox "The number entered is too large! The length of the subfield is only " & CStr( SubfieldLength% ) & " characters.", WARNING_MESSAGE, WaltsMacros$
            Dialog1ControlFunction = KEEP_DLG_OPEN
        End If
        For i = 1 To Len( UserInput$ )
          If Mid$( UserInput$, i, 1 ) Like "[!0-9]" Then
              MsgBox "Please enter digits 0-9 only!", WARNING_MESSAGE, WaltsMacros$
              Dialog1ControlFunction = KEEP_DLG_OPEN
          End If
        Next i
    End If

End Select

End Function
'43818440
'
'Macro name: CursorJump
'Macro book: C:\Program Files (x86)\OCLC\Connexion\Program\Macros\Extras1.mbk
'Saved: 6/28/2017 11:33:42 AM using "MacroBookInspector" macro by Walter F. Nickeson.
